<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/11/14/%E6%8B%9B%E9%93%B6%E9%9D%A2%E7%BB%8F/"/>
    <url>/2022/11/14/%E6%8B%9B%E9%93%B6%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="招银网络科技面经"><a href="#招银网络科技面经" class="headerlink" title="招银网络科技面经"></a>招银网络科技面经</h2><h3 id="一面-2022-10-13"><a href="#一面-2022-10-13" class="headerlink" title="一面 2022-10-13"></a>一面 2022-10-13</h3><ol><li>自我介绍</li><li><code>strcpy</code> 和 <code>memcpy</code> 的区别：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">memcpy</span> <span class="hljs-params">(<span class="hljs-type">void</span> * dest, <span class="hljs-type">const</span> <span class="hljs-type">void</span> * src, <span class="hljs-type">size_t</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">char</span> * <span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span> * dest,<span class="hljs-type">char</span> * src)</span></span>;<br></code></pre></td></tr></table></figure></li></ol><ul><li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</li><li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束。memcpy则是根据其第3个参数决定复制的长度。</li><li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li></ul><ol start="2"><li>进程通信</li></ol><ul><li>匿名管道</li><li>有名管道</li><li>信号量</li><li>消息队列</li><li>socket</li><li>共享内存</li></ul><ol start="3"><li><code>python</code> 中 <code>is</code> 和 <code>==</code> 的区别</li></ol><ul><li><code>is</code> 比较内存地址， <code>==</code> 比较内容</li></ul><ol start="4"><li><p><code>python</code> 中 <code>remove</code> 和  <code>del</code> 的区别</p></li><li><p>手撕代码：</p></li></ol><ul><li>计算最长重复子串的长度，比如输入 <code>ababc</code> 得到 <code>2</code>， <code>abababc</code> 得到 <code>3</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param a string字符串 待计算字符串</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(string a)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> n = a.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; start &lt; n; start++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>                string temp = a.<span class="hljs-built_in">substr</span>(start, i);<br>                <span class="hljs-type">int</span> len = temp.<span class="hljs-built_in">size</span>();<br>                <span class="hljs-type">int</span> tempLen = len;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = start + i; j &lt; n; j += len) &#123;<br>                    string temp2 = a.<span class="hljs-built_in">substr</span>(j, len);<br>                    <span class="hljs-keyword">if</span> (temp == temp2) &#123;<br>                        tempLen += len;<br>                        res = <span class="hljs-built_in">max</span>(res, tempLen);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="二面-2022-10-18"><a href="#二面-2022-10-18" class="headerlink" title="二面 (2022-10-18)"></a>二面 (2022-10-18)</h3><ol><li>深拷贝和浅拷贝的区别</li><li>面向对象设计原则</li><li>浅拷贝的特点</li><li>怎么检测内存泄漏</li><li>时间复杂度的数学概念</li><li>怎么检测浅拷贝重复释放</li><li><code>ipv4</code> 转 <code>16</code> 进制整数代码<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">inet_addr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* ip)</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> addr[<span class="hljs-number">4</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(ip);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cur_val = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">if</span> (*(ip + i) == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>            addr[j++] = cur_val;<br>            cur_val = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur_val = cur_val * <span class="hljs-number">10</span> + (*(ip + i) - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br><br>    &#125;<br>    addr[<span class="hljs-number">3</span>] = cur_val;<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> res = (addr[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">24</span>) + (addr[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">16</span>) + (addr[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>) + addr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> res =  <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">16</span>];<br>    <span class="hljs-built_in">sprintf</span>(str, <span class="hljs-string">&quot;0X%08x&quot;</span>, res);<br>    cout &lt;&lt; str;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/11/14/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E9%9D%A2%E7%BB%8F/"/>
    <url>/2022/11/14/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="深信服面经"><a href="#深信服面经" class="headerlink" title="深信服面经"></a>深信服面经</h1><h2 id="一面，2022-9-24"><a href="#一面，2022-9-24" class="headerlink" title="一面，2022-9-24"></a>一面，2022-9-24</h2><ol><li><code>C++</code> 继承，多态，封装</li></ol><ul><li>封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。</li><li>继承：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。</li><li>多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。</li></ul><ol start="2"><li>内存泄漏</li></ol><ul><li>并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。</li><li>常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。</li><li>使用 <code>malloc</code>、<code>calloc</code>、<code>realloc</code>、<code>new</code> 等分配内存时，使用完后要调用相应的 <code>free</code> 或 <code>delete</code> 释放内存，否则这块内存就会造成内存泄漏。</li></ul><ol start="3"><li>数组和链表的区别</li></ol><ul><li>数组是内存连续分配的数据结构</li><li>链表是内存离散的数据结构，通过指针连接起来。</li><li>数组可以随机访问，时间复杂度为<code>O(1)</code>，而链表无法随机访问，时间复杂度为<code>O(n)</code>。</li><li>数组插入和删除时间复杂度较高，需要涉及内存搬迁，而链表插入和删除的时间复杂度均为<code>O(1)</code>。</li></ul><ol start="4"><li>常用的排序算法：</li></ol><ul><li>冒泡排序，稳定排序</li><li>插入排序，稳定排序</li><li>归并排序，稳定排序</li><li>基数排序，稳定排序</li><li>希尔排序，不稳定排序</li><li>快速排序，不稳定排序</li><li>选择排序，不稳定排序</li><li>堆排序，不稳定排序</li></ul><ol start="5"><li>虚函数</li></ol><ul><li><p>实现机制：虚函数通过虚函数表来实现。虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数</p></li><li><p>虚函数表相关知识点：</p><ul><li>虚函数表存放的内容：类的虚函数的地址。</li><li>虚函数表建立的时间：编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中。</li><li>虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。</li></ul></li></ul><ol start="6"><li>手撕代码</li></ol><ul><li><a href="https://leetcode.cn/problems/reverse-substrings-between-each-pair-of-parentheses/">反转每对括号间的子串</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;string&gt; chars;<br>        string res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : s) &#123;<br>           <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>               chars.<span class="hljs-built_in">push</span>(res);<br>               res = <span class="hljs-string">&quot;&quot;</span>;<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>               <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>               res = chars.<span class="hljs-built_in">top</span>() + res;<br>               chars.<span class="hljs-built_in">pop</span>();<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               res.<span class="hljs-built_in">push_back</span>(c);<br>           &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="二面，2022-9-29"><a href="#二面，2022-9-29" class="headerlink" title="二面，2022-9-29"></a>二面，2022-9-29</h2><ol><li><p>聊项目</p></li><li><p>聊下了解的计算机基础知识</p></li></ol><ul><li>操作系统</li><li>计算网络</li></ul><ol start="3"><li>智力题</li></ol><ul><li>64匹马，8个赛道，跑多少场可以跑出前四名</li></ul><ol start="4"><li>手撕代码</li></ol><ul><li>给定一个字符串，删除字符串首尾的空格，若字符串中间存在多个空格，则只保留一个空格，例如 <code>&quot;  abc  aa cc &quot;</code> -&gt; <code>&quot;abc aa cc&quot;</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">solution</span><span class="hljs-params">(string&amp; str)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, n = str.<span class="hljs-built_in">size</span>(), j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; str[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; str[j] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            j--;<br>        &#125;<br><br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt;= j; k++) &#123;<br>            <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">empty</span>() || res.<span class="hljs-built_in">back</span>() != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                res += str[k];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!res.<span class="hljs-built_in">empty</span>() &amp;&amp; res.<span class="hljs-built_in">back</span>() == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (str[k] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    res += str[k];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/11/14/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E7%BB%8F/"/>
    <url>/2022/11/14/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="华为面经"><a href="#华为面经" class="headerlink" title="华为面经"></a>华为面经</h1><h2 id="一面，-2022-9-28，上午"><a href="#一面，-2022-9-28，上午" class="headerlink" title="一面， 2022-9-28，上午"></a>一面， 2022-9-28，上午</h2><ol><li>自我介绍</li><li>聊项目</li><li>八股文</li></ol><ul><li>已忘记，但是记得都很基础的。</li></ul><ol start="4"><li>笔试复盘</li><li>手撕代码题</li></ol><ul><li><a href="https://leetcode.cn/problems/check-if-a-string-can-break-another-string/">检查一个字符串是否可以打破另一个字符串</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkIfCanBreak</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(s1.<span class="hljs-built_in">begin</span>(), s1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s2.<span class="hljs-built_in">begin</span>(), s2.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-keyword">if</span> (s1 &gt; s2) &#123;<br>            <span class="hljs-built_in">swap</span>(s1, s2);<br>        &#125;<br><br>        <span class="hljs-type">int</span> n = s1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s1[i] &gt; s2[i]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="二面，-2022-9-28-下午"><a href="#二面，-2022-9-28-下午" class="headerlink" title="二面， 2022-9-28 下午"></a>二面， 2022-9-28 下午</h2><ol><li>自我介绍</li><li>聊项目</li><li>手撕代码(直接打开leetcode，在上面做题)</li></ol><ul><li><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">反转字符串中的单词</a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[j] == <span class="hljs-string">&#x27; &#x27;</span>; j--);<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[j] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                j--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i = j;<br>                <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                    i--;<br>                &#125;<br>                res += s.<span class="hljs-built_in">substr</span>(i + <span class="hljs-number">1</span>, j - i) + <span class="hljs-string">&quot; &quot;</span>;<br>                j = i;<br>            &#125;<br>        &#125;<br>        res.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/11/14/%E4%B8%AD%E5%85%B4%E9%9D%A2%E7%BB%8F/"/>
    <url>/2022/11/14/%E4%B8%AD%E5%85%B4%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="中兴"><a href="#中兴" class="headerlink" title="中兴"></a>中兴</h1><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><h2 id="三面-转岗位了，转到什么算法和软件相关的，-2022-10-17"><a href="#三面-转岗位了，转到什么算法和软件相关的，-2022-10-17" class="headerlink" title="三面 (转岗位了，转到什么算法和软件相关的， 2022-10-17)"></a>三面 (转岗位了，转到什么算法和软件相关的， 2022-10-17)</h2><ol><li>自我价绍</li><li>项目介绍</li><li>进程通信方法</li><li><code>4MB</code> 的图像数据用什么进程通信方法比较好</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/11/13/hello-world/"/>
    <url>/2022/11/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>tightFrameRes</title>
    <link href="/2021/04/22/tightFrameRes/"/>
    <url>/2021/04/22/tightFrameRes/</url>
    
    <content type="html"><![CDATA[<h1 id="基于三维紧框架的MRI图像重建-师兄毕设"><a href="#基于三维紧框架的MRI图像重建-师兄毕设" class="headerlink" title="基于三维紧框架的MRI图像重建(师兄毕设)"></a>基于三维紧框架的MRI图像重建(师兄毕设)</h1><h2 id="1-构造用于三维正则化的三维图像数据"><a href="#1-构造用于三维正则化的三维图像数据" class="headerlink" title="1.构造用于三维正则化的三维图像数据"></a>1.构造用于三维正则化的三维图像数据</h2><p>使用目标图像和线圈灵敏度估计出每个线圈缺失的k-空间数据，再结合已获得的准确k-空间数据，通过傅里叶逆变换得到线圈图像。计算出多幅二维图像数据后按照线圈顺序进行叠放，构造出三维图像数据，构造过程如下图1所示.</p><p><img src="1.png" alt="图1"><br>其中橙色和蓝色实线分别表示估计数据与采集到的数据，虚线表示缺失行，先通过目标图像u与灵敏度信息估计出缺失的k-空间数据，结合已获取的k-空间数据g，得到填充后的完整的k-空间数据，再通过傅里叶逆变换得到三维图像数据。$u$ 为目标图像，$g$ 为获取的下采样 $k$-空间数据, $Q_p$ 为采样矩阵，$Q_0=I-Q_p$ 表示非采样位置, $M$ 为傅里叶变换 $𝐹$ 和线圈灵敏度信息 $𝑆$ 的合并.</p><h2 id="2-三维正则化-SENSE-重建模型"><a href="#2-三维正则化-SENSE-重建模型" class="headerlink" title="2. 三维正则化 SENSE 重建模型"></a>2. 三维正则化 <code>SENSE</code> 重建模型</h2><p>本文基于SENSE模型，提出三维正则化 <code>SENSE</code> 重建模型 <code>SENSE-3D</code>:<br>$$<br>\hat{u}=argmin_u { \frac{1}{2} \Vert Q_pMu-g\Vert_2^2+\Vert \Gamma W_{3D}F^{-1}_P(Q_0Mu+g) \Vert_1 }<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>MRI重建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>admm</title>
    <link href="/2021/04/20/admm/"/>
    <url>/2021/04/20/admm/</url>
    
    <content type="html"><![CDATA[<h1 id="Admm"><a href="#Admm" class="headerlink" title="Admm"></a>Admm</h1><ol><li>增广拉格朗日 <code>Augmented Lagrangians</code>. 例如，我们可以将最小化问题 $f(x) + g(x)$ 写成：<br>$$<br>\begin{aligned}<br> minimize&amp; \quad f(x) + g(z) \<br> s.t . &amp; \quad x - z = 0<br>\end{aligned}<br>$$<br>该约束优化问题的增广拉格朗日写为：</li></ol><p>$$<br>L_\rho (x, z, y) = f(x) + g(z) + y^T(x-z)+\frac{\rho}{2}\Vert x-z\Vert_2^2<br>$$<br>其中 $\rho &gt; 0$, $y$ 是对偶变量。此时的 <code>ADMM</code> 求解形式为：</p><p>$$<br>\begin{aligned}<br>    &amp;x_{k+1} = argmin_x  L_\rho(x, z^k, y^k) \<br>    &amp;z_{k+1} = argmin_z  L_\rho(x^{k+1}, z, y^k) \<br>    &amp;y_{k+1} = y^k+\rho(x^{k+1}-z^{k+1})<br>\end{aligned}<br>$$</p><ol start="2"><li><code>ADMM</code> 的 <code>proximal version</code><br>$$<br>\begin{aligned}<br> x^{k+1} &amp;= argmin_x  L_\rho(x, z^k, y^k) \<pre><code>     &amp;= argmin_x f(x) +g(z^k)+(y^k)^T(x-z^k)+\frac&#123;\rho&#125;&#123;2&#125;\Vert x-z^k\Vert_2^2 \\     &amp;= argmin_x f(x) +(y^k)^Tx+\frac&#123;\rho&#125;&#123;2&#125;\Vert x-z^k\Vert_2^2 \\     &amp;= argmin_x f(x) + \frac&#123;\rho&#125;&#123;2&#125;\Vert x-z^k+(1/ \rho)y^k\Vert_2^2 + (y^k)^Tz^k - \frac&#123;1&#125;&#123;2\rho&#125;\Vert y^k \Vert_2^2 \\     &amp;= argmin_x f(x) + \frac&#123;\rho&#125;&#123;2&#125;\Vert x-z^k+(1/ \rho)y^k\Vert_2^2\\     &amp;= prox_&#123;\lambda f&#125;(z^k - u^k)</code></pre>\end{aligned}<br>$$</li></ol><p>$$<br>\begin{aligned}<br>    z^{k+1} &amp;= argmin_x  L_\rho(x^k, z, y^k) \<br>            &amp;= argmin_x f(x^k) +g(z)+(y^k)^T(x^k-z)+\frac{\rho}{2}\Vert x^k-z\Vert_2^2 \<br>            &amp;= argmin_x g(z) +(y^k)^Tz+\frac{\rho}{2}\Vert x^k-z\Vert_2^2 \<br>            &amp;= argmin_x g(z) + \frac{\rho}{2}\Vert x^{k+1}-z+(1/ \rho)y^k\Vert_2^2 + (y^k)^Tx^{k+1} - \frac{1}{2\rho}\Vert y^k \Vert_2^2 \<br>            &amp;= argmin_x g(z) + \frac{\rho}{2}\Vert x^{k+1}-z+(1/ \rho)y^k\Vert_2^2\<br>            &amp;= prox_{\lambda g}(x^{k+1} + u^k)<br>\end{aligned}</p><p>$$</p><p>其中 $u^k = (1/ \rho)y^k, \lambda=1/ \rho$,因此：<br>$$<br>\begin{aligned}<br>    &amp;x^{k+1} = prox_{\lambda f}(z^k - u^k)\<br>    &amp;z^{k+1} = prox_{\lambda g}(x^{k+1} + u^k)\<br>    &amp;u^{k+1} = u^k+x^{k+1}-z^{k+1}<br>\end{aligned}<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux</title>
    <link href="/2021/04/01/linux/"/>
    <url>/2021/04/01/linux/</url>
    
    <content type="html"><![CDATA[<h1 id="记录-ubuntu-常见错误和操作等"><a href="#记录-ubuntu-常见错误和操作等" class="headerlink" title="记录 ubuntu 常见错误和操作等"></a>记录 <code>ubuntu</code> 常见错误和操作等</h1><h3 id="1-ubuntu-输入-python-报不存在"><a href="#1-ubuntu-输入-python-报不存在" class="headerlink" title="1. ubuntu 输入 python 报不存在"></a>1. <code>ubuntu</code> 输入 <code>python</code> 报不存在</h3><p>错误截图如下所示：</p><div align=center><img src="https://i.loli.net/2021/04/01/JjC2B3q6pdvnWtV.png" width="50%" alt=""/></div><p>但是输入 <code>python3</code> 却能正常工作，主要原因是系统自动将软链接命名为  <code>python3</code>。<br>在 <code>/bin</code> 文件目录下输入以下语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l | grep python3  </span><br></pre></td></tr></table></figure><p>结果为：</p><div align=center><img src="https://i.loli.net/2021/04/01/SeGJVHz6CZ8UEvB.png" width="80%" alt=""/></div><p>此时我们可以将 <code>python3.8</code> 重新进行软连接，新的名字为 <code>python</code>, 具体操作为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s python3.8 python</span><br></pre></td></tr></table></figure><p>此时重新输入 <code>python</code> 就能正常工作了。</p><h3 id="2-chmod-的用法"><a href="#2-chmod-的用法" class="headerlink" title="2. chmod 的用法"></a>2. <code>chmod</code> 的用法</h3><ul><li> 字母法:<code>chmod (u g o a) (+ - =) (r w x) [文件名]</code>, <code>u</code>表示文件的所有者，<code>g</code>表示与文件的所有者属于同一组，即用户组，<code>o</code>表示其他组，<code>a</code>表示所有，即三者皆是。</li><li> <code>+</code>表示增加权限，<code>-</code>表示撤销权限，<code>=</code>表示设定权限，<code>r, w, x</code>分别表示可读，可写，可执行。</li><li> 例如对一个文件添加可执行权限，可以为<code>sudo chmod u+x filename</code>.</li><li>数字法，用法为<code>chmod 数字组合 filename</code>，数字组合由三个数字组成，第一个数字代表<code>u</code>，第二个数字代表<code>g</code>，第三个数字代表<code>o</code>。<code>rwx</code>权限使用三位二进制数字进行表示，例如<code>100,010,001</code>分别<code>r,w,x</code>，换算成十进制分别是4，2，1。</li><li>例如使用数字法：<code>chmod 777 filename</code>，表示<code>u，g,o</code>三种用户对该文件可读可写可执行。</li></ul><h3 id="3-Linux压缩文件，解压文件"><a href="#3-Linux压缩文件，解压文件" class="headerlink" title="3 Linux压缩文件，解压文件"></a>3 Linux压缩文件，解压文件</h3><ul><li><p>zip文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unzip filename.zip</span><br><span class="line">unzip filename.zip -d diretory (把文件解压到指定的目录下)</span><br></pre></td></tr></table></figure></li><li><p>tar解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf filename.tar.gz</span><br><span class="line">tar -xvf filename.tar</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-Win10-ubuntu子系统目录"><a href="#4-Win10-ubuntu子系统目录" class="headerlink" title="4 Win10 ubuntu子系统目录"></a>4 Win10 ubuntu子系统目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>soft-threshold</title>
    <link href="/2021/03/31/soft-threshold/"/>
    <url>/2021/03/31/soft-threshold/</url>
    
    <content type="html"><![CDATA[<h1 id="软阈值"><a href="#软阈值" class="headerlink" title="软阈值"></a>软阈值</h1><p>[TOC]</p><h2 id="1-2-das"><a href="#1-2-das" class="headerlink" title="1.2 das"></a>1.2 das</h2><ul><li>根据 <code>proximal operator</code> 的定义，一个函数 <code>f(x)</code> 的 <code>proximal operator</code> 如下公式所示：</li></ul><p>$$<br>prox_{\lambda f} = argmin(f(x) + \frac{1}{2 \rho}\Vert x- v\Vert^2_2)<br>$$</p><ul><li>当函数 <code>f(x) = |x|</code> 时，<code>f(x)</code> 的 <code>proximal operator</code> 此时为软阈值，为：</li></ul><p>$$<br>prox_{\lambda f} =<br>\begin{cases}<br>v-\lambda \quad v &gt; \lambda  \<br>0 \quad \quad \quad |v| \le \lambda \<br>v + \lambda \quad v &lt; -\lambda<br>\end{cases}<br>$$</p><ul><li>证明：</li></ul><ol><li><p>当 $v \in [-\lambda, \lambda]$, 通过 $0 \in \partial(\lambda|x|) + x -v$,可以得到：<br>$$<br>\begin{aligned}<br>&amp;x = 0, \quad \partial(\lambda|x|) + x -v = 0 , \quad \<br>&amp;x &gt; 0, \quad \partial(\lambda|x|) + x -v = \lambda + x -v &gt; 0 \<br>&amp;x &gt; 0, \quad \partial(\lambda|x|) + x -v = -\lambda + x -v &lt; 0 \<br>&amp;so \quad prox_{\lambda f}(v) = 0<br>\end{aligned}<br>$$</p></li><li><p> 当 $v &gt; \lambda$, 通过 $0 \in \partial(\lambda|x|) + x -v$,可以得到：<br>$$<br>\begin{aligned}<br>&amp;x = 0, \quad \partial(\lambda|x|) + x -v &lt; 0 , \quad \<br>&amp;x &gt; 0, \quad \partial(\lambda|x|) + x -v = \lambda + x -v = 0 \<br>&amp;x &gt; 0, \quad \partial(\lambda|x|) + x -v = -\lambda + x -v &lt; 0 \<br>&amp;so \quad prox_{\lambda f}(v) =  v- \lambda<br>\end{aligned}<br>$$</p></li><li><p> 当 $v  &lt; -\lambda$, 通过 $0 \in \partial(\lambda|x|) + x -v$,可以得到：<br>$$<br>\begin{aligned}<br>&amp;x = 0, \quad \partial(\lambda|x|) + x -v &gt; 0 , \quad \<br>&amp;x &gt; 0, \quad \partial(\lambda|x|) + x -v = \lambda + x -v &gt; 0 \<br>&amp;x &gt; 0, \quad \partial(\lambda|x|) + x -v = -\lambda + x -v = 0 \<br>&amp;so \quad prox_{\lambda f}(v) =  v+ \lambda<br>\end{aligned}<br>$$</p></li><li><p>软阈值另一种等价形式<br>$$<br>prox_{\lambda f}(v) = sign(v) max{|v| - \lambda, 0}<br>$$</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旋转链表</title>
    <link href="/2021/03/30/%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/03/30/%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/rotate-list/">旋转链表</a></p><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p><p><img src="https://i.loli.net/2021/03/30/7aTelS1Mmpv5XB9.png" alt="image.png"></p><ul><li>当k是n的整数倍时，即 <code>k % n = 0</code>, 此时可以直接返回链表头节点 <code>head</code> .</li><li>当 <code>head</code> 为空时，或者链表长度为1时，此时直接返回链表头节点 <code>head</code> 。</li><li>否则，将链表构建成一个循环链表，即将链表尾巴 <code>tail-&gt;next = head</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    id1((1))</span><br><span class="line">    id2((2))</span><br><span class="line">    id3((3))</span><br><span class="line">    id4((4))</span><br><span class="line">    id5((5))</span><br><span class="line">    id1 --&gt; id2</span><br><span class="line">    id2 --&gt; id3</span><br><span class="line">    id3 --&gt; id4</span><br><span class="line">    id4 --&gt; id5</span><br><span class="line">    id5 --&gt; id1</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>形成循环链表之后，在合适的位置断开。</li><li>通过观察发现， 当 <code>k = 2</code>, <code>n = 5</code>时，此时的链表应该以数字 <code>3</code> 结尾，此时对应的是链表的第 <code>3</code> 个元素。</li><li>当 <code>k = 3</code> 时，此时的链表应该以数字 <code>2</code> 结尾，此时对应的是链表的第 <code>2</code> 个元素。</li><li>因此，我们可以发现通过移动链表 <code>k</code> 个元素之后， 移动后的链表的尾部是原来链表的第 <code>n - k</code> 个元素。</li><li>不失一般性， 当 <code>k &gt;= n </code> 时， 此时的计算公式为  <code>n - k %  n</code>。</li><li>通过以上分析，便可以写出如下的代码啦。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//计算链表长度</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            n++;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> add = n - k % n;</span><br><span class="line">        <span class="keyword">if</span> (add == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = head; <span class="comment">// 形成循环链表</span></span><br><span class="line">        <span class="keyword">while</span> (add--) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* r = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vector介绍</title>
    <link href="/2021/03/19/vector%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/03/19/vector%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><ul><li><p>vector定义摘要</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"> <span class="comment">/// 省略一万字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>vector的构造函数</p></li></ul><ol><li>默认构造函数 <code>vector()</code>;</li><li><code>vector(size_type n, const T&amp; value)</code>;</li><li>拷贝构造函数<code>vector (const vector&amp; x)</code>, <code>vector (const vector&amp; x, const allocator_type&amp; alloc)</code>;</li><li>范围构造函数`vector (InputIterator first, InputIterator last,<pre><code>   const allocator_type&amp; alloc = allocator_type());`</code></pre></li><li>移动构造函数<code>vector (vector&amp;&amp; x); vector (vector&amp;&amp; x, const allocator_type&amp; alloc);</code></li><li>列表构造函数`vector (initializer_list<value_type> il,<pre><code>const allocator_type&amp; alloc = allocator_type());`</code></pre></li></ol><ul><li>vector的元素操作</li></ul><ol><li><code>push_back(const T&amp; x)</code>:向尾部插入元素</li><li><code>pop_back()</code>:删除尾端元素</li><li><code>iterator erase(iterator first, iterator last)</code>:清除[first, last)的所有元素</li><li><code>iterator erase(iterator positin)</code>:清除某个位置上的元素，返回值为一个迭代器，指向函数调用删除的最后一个元素后面的元素的新位置。</li><li>例子 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// erasing from vector</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; myvector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set some values (from 1 to 10)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) myvector.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// erase the 6th element</span></span><br><span class="line">myvector.<span class="built_in">erase</span> (myvector.<span class="built_in">begin</span>()+<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// erase the first 3 elements:</span></span><br><span class="line"><span class="keyword">auto</span> i=myvector.<span class="built_in">erase</span> (myvector.<span class="built_in">begin</span>(),myvector.<span class="built_in">begin</span>()+<span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; *i &lt;&lt;endl; <span class="comment">//此时的i指向值为4 的元素</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;myvector contains:&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i=<span class="number">0</span>; i&lt;myvector.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; myvector[i];</span><br><span class="line">std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output：</span><br><span class="line"><span class="number">4</span></span><br><span class="line">myvector contains: <span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></li><li><code>void insert(positon, n x)</code>:从positin开始，插入n个元素，初值为x</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>C++, STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在.h文件定义函数出现的错误</title>
    <link href="/2021/03/16/%E5%9C%A8-h%E6%96%87%E4%BB%B6%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF/"/>
    <url>/2021/03/16/%E5%9C%A8-h%E6%96%87%E4%BB%B6%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%87%BA%E7%8E%B0%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="在-h定义函数，会在什么阶段发生错误"><a href="#在-h定义函数，会在什么阶段发生错误" class="headerlink" title="在.h定义函数，会在什么阶段发生错误"></a>在.h定义函数，会在什么阶段发生错误</h1><p>如果把函数定义放在头文件，在复杂的工程文件中会出现重定义等错误。为了说明，使用以下例子进行说明。</p><ul><li><p>首先新创建一个工程文件项目，包含<code>A.h</code> , <code>B.h</code> , <code>B.cpp</code> , <code>C.h</code> , <code>C.cpp</code> , <code>main.cpp</code>。各文件内容如下代码所示：</p></li><li><p><code>A.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _A_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _A_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun_A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>B.h</code>和<code>B.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _B_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _B_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun_B</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//B.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;B.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun_B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fun_A</span>() +  <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>C.h</code>和<code>C.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _C_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _C_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun_C</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;C.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun_C</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fun_A</span>() +  <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>main.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;B.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;C.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">fun_B</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">fun_C</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后分别对<code>B.cpp</code>，<code>C.cpp</code>, <code>main.cpp</code>进行编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ -c B.cpp -o B.obj</span><br><span class="line">g++ -c C.cpp -o C.obj</span><br><span class="line">g++ -c main.cpp -o main.obj</span><br></pre></td></tr></table></figure></li><li><p>编译后进行连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o test B.obj C.obj main.obj </span><br></pre></td></tr></table></figure></li><li><p>但是此时报错，报错内容如下所示:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: C.obj: in function `fun_A()&#x27;:</span><br><span class="line">C.cpp:(.text+0x0): multiple definition of `fun_A()&#x27;; B.obj:B.cpp:(.text+0x0): first defined here</span><br><span class="line">/usr/bin/ld: main.obj: in function `fun_A()&#x27;:</span><br><span class="line">main.cpp:(.text+0x0): multiple definition of `fun_A()&#x27;; B.obj:B.cpp:(.text+0x0): first defined here</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>错误原因分析：因为<code>B.h</code>和 <code>C.h</code>中分别都包含了 <code>A.h</code>这个头文件，最后在 <code>main.cpp</code>中分别又 <code>include</code> 了<code>B.h</code>和<code>C.h</code>两个头文件，这样就会导致在<strong>链接</strong>（link）的时候出现重定义的错误。</p></li><li><p>解决办法：</p><p>在 <code>.h</code> 文件中不进行函数的定义，只声明函数，函数的定义写在<code>.cpp</code>文件中，对于以上的项目文件中，另创建一个<code>A.cpp</code>的文件，将函数<code>fun_A</code>的定义写在<code>A.cpp</code>中，这样就可以避免在链接阶段出现函数重定义的问题了。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>include双引号和尖括号的区别</title>
    <link href="/2021/03/15/include%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%92%8C%E5%B0%96%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/03/15/include%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%92%8C%E5%B0%96%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="include-“-“-和-lt-gt-的区别"><a href="#include-“-“-和-lt-gt-的区别" class="headerlink" title="include “ “ 和 &lt;&gt; 的区别"></a>include “ “ 和 &lt;&gt; 的区别</h1><p>头文件由创建库的程序员提供。为了声明在库中已有的函数和变量，用户只需包含头文件即可。包含头文件，用使用<code>#include</code> 预处理命令。<code>#include</code>有两种方式来指定文件：尖括号 <code>&lt;&gt;</code> 或双引号 <code>&quot;&quot;</code> 。</p><ul><li><p>以尖括号来指定文件时，预处理器是以特定的方式来指定文件，一般是环境中或编译器命令行指定的某种寻找路径。这种设置寻找路径的机制随机器，操作系统，<code>C++</code> 实现的不同而不同，要视具体情况而定。以尖括号指定文件，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;header&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>用双引号时，预处理器以 “定义实现的途径” 来寻找文件。它通常是从当前目录开始寻找，如果文件没有找到，那么<code>include</code>命令就按与尖括号同样的方式重新开始寻找。以双引号指定文件，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;header&quot;</span></span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何让.h文件不被重复引用</title>
    <link href="/2021/03/15/%E5%A6%82%E4%BD%95%E8%AE%A9-h%E6%96%87%E4%BB%B6%E4%B8%8D%E8%A2%AB%E9%87%8D%E5%A4%8D%E5%BC%95%E7%94%A8/"/>
    <url>/2021/03/15/%E5%A6%82%E4%BD%95%E8%AE%A9-h%E6%96%87%E4%BB%B6%E4%B8%8D%E8%A2%AB%E9%87%8D%E5%A4%8D%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="如何让-h文件不被重复引用"><a href="#如何让-h文件不被重复引用" class="headerlink" title="如何让.h文件不被重复引用"></a>如何让.h文件不被重复引用</h1><p>为了避免让.h文件不被重复引用，有三种方式可以实现该操作，主要为：</p><ol><li>使用宏定义</li><li>使用<code>#pragma once</code>语句</li><li>使用<code>_Pragma</code>操作符</li></ol><p>例如有如下所示的 <code>C++</code> 项目，其内部含有 <code>A.h</code> 和 <code>B.h</code> 这 2 个头文件以及 <code>main.cpp</code> 源文件，其各自包含的代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// B.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;B.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行此项目后可以发现，编译器报 (VS studio 2019)<code>“A&quot; : &quot;class” 类型重定义</code> 错误。这是因为在 <code>B.h</code> 文件中已经 <code>include </code> 了一次 <code>A.h</code>，而在 <code>main.cpp </code>主程序又同时 <code> #include</code> 了 <code>A.h</code> 和 <code>B.h</code>，即 <code>A</code> 类的定义被引入了 2 次，<code>C++</code>不允许同一个类被重复定义。</p><p>因此我们此时可以使用之前提到的三种方法处理这种情况，避免头文件的重复引入。</p><ul><li><p>使用宏定义避免</p><p>在实际的<code>C++</code>开发中，可以使用如下的宏定义形式进行避免头文件重复引入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _NAME_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NAME_H</span></span><br><span class="line"><span class="comment">// 头文件内容</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>其中，_NAME_H 是宏的名称。需要注意的是，这里设置的宏名必须是独一无二的，不要和项目中其他宏的名称相同。当程序中第一次 <code>#include</code> 该文件时，由于 <code>_NAME_H</code> 尚未定义，所以会定义 <code>_NAME_H</code> 并执行 “头文件内容” 部分的代码；当发生多次 <code>#include</code> 时，因为前面已经定义了 <code>_NAME_H</code>，所以不会再重复执行 “头文件内容” 部分的代码。</p><p>因此，我们对之前的两个类文件进行修改，添加宏定义语句，代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _A_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _A_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// B.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _B_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _B_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;B.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然该项目 <code>main.cpp</code> 文件中仍 <code>#include</code> 了 2 次 <code>A.h</code>，但鉴于 <code>_A_H</code> 宏只能定义一次，所以 <code>A</code> 类也仅会定义一次。再次执行该项目会发现，其可以正常执行。</p></li><li><p>使用<code>#pragma once</code>语句</p><p>除了前面第一种最常用的方式之外，还可以使用 <code>#pragma one</code> 指令，将其附加到指定文件的最开头位置，则该文件就只会被 <code>#include</code> 一次。和 <code>ifndef</code> 相比，<code>#pragma once</code> 不涉及宏定义，当编译器遇到它时就会立刻知道当前文件只引入一次，所以效率很高。但值得一提的是，并不是每个版本的编译器都能识别 <code>#pragma once</code> 指令，一些较老版本的编译器就不支持该指令（执行时会发出警告，但编译会继续进行），即 <code>#pragma once</code> 指令的兼容性不是很好。</p></li><li><p>使用<code>_Pragma</code>操作符</p><p><code>C99</code> 标准中新增加了一个和 <code>#pragma</code> 指令类似的 <code>_Pragma </code> 操作符，其可以看做是 <code>#pragma</code> 的增强版，不仅可以实现 <code>#pragma</code> 所有的功能，更重要的是，<code>_Pragma</code> 还能和宏搭配使用。</p><p>当处理头文件重复引入问题时，可以将如下语句添加到相应文件的开头：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">_Pragma</span>(<span class="string">&quot;once&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重复项删除</title>
    <link href="/2021/03/09/%E9%87%8D%E5%A4%8D%E9%A1%B9%E5%88%A0%E9%99%A4/"/>
    <url>/2021/03/09/%E9%87%8D%E5%A4%8D%E9%A1%B9%E5%88%A0%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">删除字符串中的所有相邻重复项</a></h1><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。</p><p>思路：使用栈保存非重复项，便利字符串，当遇到的字符和栈顶元素相同时，则让栈顶元素退栈，否则入栈，最终将得到的栈转化为字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>&amp; ch : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(ch);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch == s.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.<span class="built_in">push</span>(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>c++string本身提供了类似栈的操作，因为我们不需要开多一个额外的栈进行辅助。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>&amp; ch : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!res.<span class="built_in">empty</span>() &amp;&amp; ch == res.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>俄罗斯套娃</title>
    <link href="/2021/03/08/%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83/"/>
    <url>/2021/03/08/%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83/</url>
    
    <content type="html"><![CDATA[<h1 id="俄罗斯套娃"><a href="#俄罗斯套娃" class="headerlink" title="俄罗斯套娃"></a><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">俄罗斯套娃</a></h1><p>给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。<br>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。<br>请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p>思路：首先对信封的宽度进行排序，然后求高度的最长递增子序列。求解子序列问题是一个动态规划问题，假设有序列为：<br>num=[2 1 3 5 4 7]。使用dp数组进行记录，dp[i]的值表示以num[i]作为结尾的递增子序列的长度。一开始，dp全部初始化为1， 然后更新dp的动态方程为:<br>$$<br>dp[i] = max_{0&lt;j&lt;i}(dp[i], dp[j] + 1);<br>$$</p><p>1 dp数组初始化<br>|num|2|1|3|5|4|7|<br>|–|–|–|–|–|–|–|<br>|dp|1|1|1|1|1|1|</p><p>2 更新dp[1]<br>因为num[1] &gt; num[0]不成立，所以dp[1] = 1。<br>|num|2|1|3|5|4|7|<br>|–|–|–|–|–|–|–|<br>|dp|1|1|1|1|1|1|</p><p>3 更新dp[2]<br>因为num[2] &gt; num[0]成立，所以dp[2] = dp[0]+1;<br>因为num[2] &gt; num[1]成立，所以dp[2] = dp[1]+1;<br>最后dp[2] = ，max(dp[1]+1,dp[0]+1);所以dp[2]=2。<br>|num|2|1|3|5|4|7|<br>|–|–|–|–|–|–|–|<br>|dp|1|1|2|1|1|1|</p><p>3 依次类推更新其他值<br>|num|2|1|3|5|4|7|<br>|–|–|–|–|–|–|–|<br>|dp|1|1|2|3|3|4|</p><ol start="4"><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxEnvelopes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(envelopes.<span class="built_in">begin</span>(), envelopes.<span class="built_in">end</span>(), [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        &#125;); <span class="comment">//首先进行排序</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(envelopes.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; envelopes.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (envelopes[i][<span class="number">1</span>] &gt; envelopes[j][<span class="number">1</span>] &amp;&amp; envelopes[i][<span class="number">0</span>] &gt; envelopes[j][<span class="number">0</span>]) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>); <span class="comment">//对高度求最长递增子序列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>espirit</title>
    <link href="/2021/03/04/espirit/"/>
    <url>/2021/03/04/espirit/</url>
    
    <content type="html"><![CDATA[<h1 id="ESPIRiT-An-Eigenvalue-Approach-to-Autocalibrating-Parallel-MRI"><a href="#ESPIRiT-An-Eigenvalue-Approach-to-Autocalibrating-Parallel-MRI" class="headerlink" title="ESPIRiT - An Eigenvalue Approach to Autocalibrating Parallel MRI"></a>ESPIRiT - An Eigenvalue Approach to Autocalibrating Parallel MRI</h1><h2 id="1-THEORY"><a href="#1-THEORY" class="headerlink" title="1 THEORY"></a>1 THEORY</h2><h3 id="1-1SENSE"><a href="#1-1SENSE" class="headerlink" title="1.1SENSE"></a>1.1SENSE</h3><p>&ensp;&ensp; 在MRI重建中，SENSE类方法将MRI重建视作为一个线性逆问题。假设m表示一张图像，令$S_i$ 表示第i个线圈的敏感度矩阵(对角矩阵),$F$表示离散傅里叶变换，$P$表示采样矩阵。则第i个线圈得到的数据可以表示为:<br>$$<br>y_i = PFS_i m  \quad (1)<br>$$<br>当$S_i$已知时，该问题可以直接通过最小二乘法求解。</p><h3 id="1-2-GRAPPPA"><a href="#1-2-GRAPPPA" class="headerlink" title="1.2 GRAPPPA"></a>1.2 GRAPPPA</h3><p>&ensp;&ensp; GRAPPA是一种逐线圈自动校准的重建算法，该算法将重建过程视作为一个k空间的插值过程，将未获得k空间数据通过已获得的数据进行线性组合得到。</p><p>&ensp;&ensp;为了描述GRAPPA算法，定义一些符号</p><ul><li>$R_r$ :该算子表示从位置r周围的所有网格中选择一个k空间块。</li><li>$P_r$ :仅从k空间块中选择采集样本的局部采样模式。</li><li>$y$ :向量形式的多线圈k空间网格，未获取的数据被零填充。</li><li>$x_i$ :第i个线圈中重建后得到的数据</li><li>$x_i(r)$ :第i个线圈中，位置r的重建数据</li><li>$g_{ri}$ :GRAPPA kernel</li></ul><p>&ensp;&ensp;在GRAPPA重建算法中，在位置r中未采样的数据由以下式子得到：<br>$$<br>x_i(r)=(P_rR_ry)^Tg_{ri} \quad (2)<br>$$<br>因此当GRAPPA kernel未知，$x_i$已知时，我们可以通过求解(2)得到$g_{ri}$。一般情况下，在得到的k空间数据中有一块全采样的数据，位于数据中心，这块数据被称为校准数据(calibration data),通过该数据得到矩阵被称为标准矩阵(calibration matrix)，记为A。如Figure 1，左上角为得到的k空间数据，该数据中央黑色部分为全采样，即为标准矩阵(上中图)。上右图是校准数据得到的校准矩阵，该矩阵通过设置一个窗口(3*3),然后将窗口中的数据拉成一行向量，即可以得到校准矩阵的一行向量，再通过滑动该窗口，不断得到校准矩阵的数据。</p><p>&ensp;&ensp; 为了得到GRAPPA kernel，使用校准矩阵改写式子(2),</p><p>$$<br>\begin{aligned}<br>x_i(r)&amp;=(P_rR_ry)^Tg_{ri} \<br>          &amp;=y^TR_r^TP_r^Tg_{ri}\<br>          &amp;=(R_ry)^TP_r^Tg_{ri} \<br>          &amp;=AP_r^Tg_{ri}<br>\end{aligned}<br>$$<br>若用$y_i^{AC}$表示第i个线圈得到的校准数据，则可以得到式子(3)<br>$$<br>y_i^{AC} = AP_r^Tg_{ri} \quad (3)<br>$$<br>通过求解式子(3), 可以得到未知的$g_{ri}$，一般通过Tikhonov正则化最小二乘法进行求解。<br>$$<br>argmin_{g_{ri}} \Vert AP_r^T-y_i^{AC} \Vert^2<br>$$</p><p>通过构造，矩阵A的一个列是$y_i^{AC}$，如Figure 1 中上中图和上右图所以，橙色部分的一块一矩阵即为矩阵A的第五列。因为可以将$y_i^{AC}$写成 $Ae_i$,$e_i$表示某个位置为1，其他为0为的向量，用于选择矩阵的第i列。因此通过该性质，重写式子(3),可以写成：</p><p>$$<br>\begin{aligned}<br>0&amp;=AP_r^Tg_{ri}-y_i^{AC}\<br>&amp;=AP_r^Tg_{ri}-Ae_i \<br>&amp;=A(P_r^Tg_{ri} - e_i) \quad (4)<br>\end{aligned}<br>$$<br>从式子(4)中可以发现，$P_r^Tg_{ri} - e_i$是矩阵A的零空间向量。零空间的存在意味着A中存在冗余，从而意味着k空间块之间的相关性，这可以用来合成丢失的样本。由于零空间的特殊性，因此我们可以直接分析零空间。</p><p><img src="https://i.loli.net/2021/03/08/OaNkGrSzJKZADVb.png" alt="Figure 1"></p><h3 id="1-3-SVD和零空间重建"><a href="#1-3-SVD和零空间重建" class="headerlink" title="1.3 SVD和零空间重建"></a>1.3 SVD和零空间重建</h3><p>&ensp;&ensp; 使用奇异值分解的方法分析校准矩阵A，奇异值分解的形式为：<br>$$<br>A=U\Sigma V^H \quad (5)<br>$$<br>矩阵V的列是矩阵行空间的基，因此可以将矩阵V分成$V_{\bot}$和$V_{\Vert}$,分别span A的零空间和行空间。从Figure 2 中可以看出，对校准矩阵矩阵进行奇异值分解后，我们可以利用$V_{\Vert}$的数据推出未采样的数据。</p><p>&ensp;&ensp; 给定欠采样的k空间网格，重构x的每个k空间块必须满足两个约束:<br>$$<br>\begin{aligned}<br>V_{\Vert}V_{\Vert}^HR_rx &amp;= R_rx  \quad or \quad V_{\bot}^HR_rx = 0 \quad &amp;(6a)\<br>P_rR_rx&amp;=P_rR_rx \quad &amp;(6b)<br>\end{aligned}<br>$$<br>(6a)是与校准的一致性，(6b)是与数据采集的一致性。在最小二乘意义上解释(形式上超定的)零空间约束集产生了正规方程</p><p>$$<br>\sum_{r}R_r^HV_{\bot}V_{\bot}^HR_rx = 0 \quad (7)<br>$$</p><p>式子(7)进一步可以写成</p><p>$$<br>\sum_{r}R_r^H (I- V_{\Vert}V_{\Vert}^H) R_rx = 0 \quad (8)<br>$$</p><p>$$<br>M^{-1}\sum_{r}R_r^H V_{\Vert}V_{\Vert}^H R_rx = 0 \quad (9)<br>$$<br>其中式子(9)中的M表示$\sum_{r}R_r^HR_r$。以矩阵形式重写第一个约束，并合并第二个约束的所有相同的方程，得到<br>$$<br>\begin{aligned}<br>\mathcal{W}x &amp;=x  \quad (10a)\<br>\mathcal{P}x &amp;= \mathcal{P}y \quad (10b)<br>\end{aligned}<br>$$</p><p><img src="https://i.loli.net/2021/03/08/aPNvjHZbIAgxSym.png" alt="Figure 2"></p><h3 id="1-4-Sensitivity-map-as-an-eigenvalue-problem"><a href="#1-4-Sensitivity-map-as-an-eigenvalue-problem" class="headerlink" title="1.4 Sensitivity map as an eigenvalue problem"></a>1.4 Sensitivity map as an eigenvalue problem</h3><p>&ensp; &ensp; 假设x是W-I的零空间的解，则满足$Wx=x$。如果我们用线圈灵敏度加权的原始图像的k空间表示x，得到<br>$$<br>x=FSm \quad (11)<br>$$<br>其中，$S=[S_1,S_2,…,S_N]^T$ 是堆叠线圈灵敏度的向量，则等式(10a)可以写为：<br>$$<br>WFSm = FSm \quad (12)<br>$$<br>两边都进行傅里叶逆变换可以得到，<br>$$<br>F^{-1}WFSm=Sm \quad (13)<br>$$<br>通过式子(13)可以看出，1是矩阵$F^{-1}WF$的特征值，特征向量是$Sm$.因为算子W是半正定矩阵值卷积，所以它在图像域中解耦成点态半正定矩阵运算:<br>$$<br>F^{-1}\mathcal{W}F|_q=\mathcal{G_q} \quad (14)<br>$$<br>算子W的特征值分解被简化为求解图像空间中$G_q$每个位置q的特征值分解。计算$G_q$的过程如Figure 4所示。定义在位置q上的敏感度$\vec{s}(q)=[s_1(q),…,s_N(q)]^T$,则等式(13)可以推出：<br>$$<br>\mathcal{G_q}\vec{s}(q)m(q)=\vec{s_r}m(q) \quad (15)<br>$$<br>假设$m(q)$不等于0，则可以得到：<br>$$<br>\mathcal{G_q}\vec{s}(q)=\vec{s_q} \quad (15)<br>$$<br>因此，显式灵敏度图可以通过所有Gq的特征值分解找到，只选择对应于特征值” =1 “的特征向量<br><img src="https://i.loli.net/2021/03/08/uXNIlDFy2h6kYe3.png" alt="Figure 4"></p><h3 id="1-5-ESPIRiT-Implementation-Using-Soft-SENSE"><a href="#1-5-ESPIRiT-Implementation-Using-Soft-SENSE" class="headerlink" title="1.5 ESPIRiT : Implementation Using Soft SENSE"></a>1.5 ESPIRiT : Implementation Using Soft SENSE</h3><p>&ensp;&ensp;在计算一组灵敏度后，可以执行标准的SENSE重建。在某些情况下，采集中的误差会导致出现特征值为“=1”的多个特征向量或小于1的附加特征值，这表明信号分量不能用严格的SENSE模式来解释。这推动了重建过程的扩展:不是使用一组单一的灵敏度图，而是使用等式(1)扩展到“软”SENSE重建，其使用基于多个图像分量$m^j$和多组映射$S^j$的信号的松弛模型:</p><p>$$<br>y_i=\mathcal{P} \mathcal{F}\sum_{j=1}^{M}S_i^jm^j \quad (16)<br>$$<br>如上所述，重建图像的求解为一个优化问题，并且使用正则化方法，具体的形式如下所示：</p><p>$$<br>J(m^1,…,m^M)=\sum_{i=1}^{N}\Vert y_i-\mathcal{P} \mathcal{F}\sum_{j=1}^{M}S_i^jm^j \Vert^2_2 + \alpha\sum_{j=1}^{M}\mathcal{Qm^j}  \quad (17)<br>$$</p><h2 id="2-code-Implementation-demo-ESPIRIT-l1-recon"><a href="#2-code-Implementation-demo-ESPIRIT-l1-recon" class="headerlink" title="2 code Implementation(demo_ESPIRIT_l1_recon)"></a>2 code Implementation(demo_ESPIRIT_l1_recon)</h2><h3 id="2-1-construct-Calibration-matrix-A-and-V-Vert"><a href="#2-1-construct-Calibration-matrix-A-and-V-Vert" class="headerlink" title="2.1 construct Calibration matrix A and $V_{\Vert}$"></a>2.1 construct Calibration matrix A and $V_{\Vert}$</h3><p>&ensp;&ensp;构造校准矩阵A之前，首先必须找到ACS，通过使用函数crop寻找校准区域<code>calib</code>，然后通过<code>calib</code>构造校准矩阵。</p><p>&ensp;&ensp;各类函数解释说明</p><ul><li><code>im2row(im, winSize)</code>:该函数将滑动窗口的数据拉成行向量，然后不用滑动窗口，得到一个Hankel矩阵。如<code>Figure 5</code>所示</li></ul><p><img src="https://i.loli.net/2021/03/22/3RKe5hN1rdlpZSo.png" alt="Figure 5"></p><ul><li>函数<code>dat2Kernel</code>:该函数接受两个参数，分别是<code>data</code>和<code>kSize</code>，表示校准数据和<code>kernel</code>的大小。该函数首先通过调用im2row函数得到临时变量<code>tmp</code>，然后将<code>tmp reshape</code>成二维矩阵，对A矩阵进行<code>SVD</code>分解，对应公式(5)。进行分解之后，将A的右奇异向量取出，<code>reshape</code>成一个一个的kernel。变换过程如下图所示：<br><img src="https://i.loli.net/2021/03/22/D3fVXc8QwIlYRHs.png" alt="Figure 6"><br><img src="https://i.loli.net/2021/03/22/vnyrdfjXYiVCsa9.png" alt="Figure 7"></li></ul><ul><li><code>[EigenVecs, EigenVals] = kernelEig(kernel, imSize)</code>:还函数用于计算特征向量和特征值。<code>kernel</code>是上一个函数<code>dat2Kernel</code>得到的结果并且去掉一些奇异值特别小的右奇异向量。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MRI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>倒数第k个结点</title>
    <link href="/2021/01/20/%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <url>/2021/01/20/%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="输出该链表中倒数第k个节点"><a href="#输出该链表中倒数第k个节点" class="headerlink" title="输出该链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">输出该链表中倒数第k个节点</a></h1><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.<br>返回链表 4-&gt;5.</p><p>思路：使用双指针，一个快指针，一个慢指针，先让快指针走k步，然后快慢指针一起走，直到快指针指向链表尾部时，慢指针就指向链表倒数第k个结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; fast; i++, fast = fast-&gt;next);</span><br><span class="line">        <span class="keyword">while</span> (slow &amp;&amp; fast) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人的运动范围</title>
    <link href="/2021/01/19/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <url>/2021/01/19/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">机器人的运动范围</a></h1><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p>输入：m = 2, n = 3, k = 1</p><p>输出：3</p><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>0</td><td>(0 0)</td><td>(0 1)</td><td>(0 2)</td></tr><tr><td>1</td><td>(1 0)</td><td>(1 1)</td><td>(1 2)</td></tr></tbody></table><p>因为机器人能够到达的格子是(0 0),(0 1), (1 0)。<br>思路：使用DFS或者BFS进行搜索，用一个全局变量记录符合条件的格子数。</p><p>DFS思路：使用一个vis数组，记录访问过的各自，true为访问过，false为未访问。<br>DFS函数参数：vis,m,n,x(当前格子横坐标),y(当前格子纵坐标)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">vis</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n));</span><br><span class="line">    <span class="built_in">dfs</span>(vis, m, n, <span class="number">0</span>, <span class="number">0</span>, k);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; vis, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; direction&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; i : direction) &#123;</span><br><span class="line">        <span class="type">int</span> a = x + i.first;</span><br><span class="line">        <span class="type">int</span> b = y + i.second;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; m &amp;&amp; b &lt; n &amp;&amp; !vis[a][b] &amp;&amp; <span class="built_in">count</span>(a, b) &lt;= k)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="built_in">dfs</span>(vis, m, n, a, b, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        sum = sum + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        sum = sum + y % <span class="number">10</span>;</span><br><span class="line">        y /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BFS</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">vis</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n));</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; path;</span><br><span class="line">    path.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; direction&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    vis[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!path.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [x, y] = path.<span class="built_in">front</span>();</span><br><span class="line">        path.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; d : direction) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + d.first &gt;= m || y + d.second &gt;= n || vis[x + d.first][y + d.second] || <span class="built_in">count</span>(x + d.first, y + d.second) &gt; k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                vis[x+d.first][y+d.second] = <span class="literal">true</span>;</span><br><span class="line">                path.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x+d.first, y+d.second));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冗余连接</title>
    <link href="/2021/01/13/%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/"/>
    <url>/2021/01/13/%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="冗余连接"><a href="#冗余连接" class="headerlink" title="冗余连接"></a><a href="https://leetcode-cn.com/problems/redundant-connection/">冗余连接</a></h2><pre><code>在本问题中, 树指的是一个连通且无环的无向图。输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的无向图为:</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id1((1))</span><br><span class="line">id2((2))</span><br><span class="line">id3((3))</span><br><span class="line">id1---id2</span><br><span class="line">id1---id3</span><br><span class="line">id2---id3</span><br></pre></td></tr></table></figure><pre><code>解释：因此该图可以删除边[2,3],使之成为一个树思路：利用并查集的思想，并查集是一个不相交的集合，一般可以用于连通片的计算等。最经常用的地方就是在克鲁斯卡尔生成树算法中。并查集可以用数组的形式进行实现，例如有一个图[[1,2], [2,3], [3,4], [1,4], [1,5]]。</code></pre><ol><li>并查集一开始初始化为如下表所示：</li></ol><table><thead><tr><th>index</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>father</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr></tbody></table><ol start="2"><li>然后逐渐添加边，</li></ol><table><thead><tr><th>index</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>father</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>3. 代码如下所示</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">father</span><span class="params">(edges.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; father.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(father, edge[<span class="number">0</span>]) != <span class="built_in">find</span>(father, edge[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="built_in">Union</span>(father, edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; father, <span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        father[<span class="built_in">find</span>(father, a)] = father[<span class="built_in">find</span>(father, b)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span>  <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; father, <span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (a != father[a]) &#123;</span><br><span class="line">            a = father[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>go</title>
    <link href="/2020/12/25/go/"/>
    <url>/2020/12/25/go/</url>
    
    <content type="html"><![CDATA[<h1 id="Go语言"><a href="#Go语言" class="headerlink" title="Go语言"></a>Go语言</h1><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><pre><code>1. 每个 Go 程序都是由包构成的。程序从 main 包开始运行。本程序通过导入路径 &quot;fmt&quot; 来使用它</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>2. 此代码用圆括号组合了导入，这是“分组”形式的导入语句。也可以编写多个导入语句，例如：</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><pre><code>1. var 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。2. 变量声明可以包含初始值，每个变量对应一个。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">var</span> c, python, java <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> i, j <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">fmt.Println(i, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>3. 短变量声明：在函数中，简洁赋值语句 := 可在类型明确的地方代替 var 声明。函数外的每个语句都必须以关键字开始（var, func 等等），因此 := 结构不能在函数外使用。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i, j <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">k := <span class="number">3</span></span><br><span class="line">c, python, java := <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;no!&quot;</span></span><br><span class="line">fmt.Println(i, j, k, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>4. 基本类型：boolstringint  int8  int16  int32  int64uint uint8 uint16 uint32 uint64 uintptrbyte // uint8 的别名rune // int32 的别名    // 表示一个 Unicode 码点float32 float64complex64 complex1285. 常量：常量的声明与变量类似，只不过是使用 const 关键字。常量可以是字符、字符串、布尔值或数值。常量不能用 := 语法声明。</code></pre><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a><strong>for</strong></h3><pre><code>1. Go 只有一种循环结构：for 循环。2. 基本的 for 循环由三部分组成，它们用分号隔开：    初始化语句：在第一次迭代前执行    条件表达式：在每次迭代前求值    后置语句：在每次迭代的结尾执行</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>3. 去掉分号的for循环就成了while循环(go语言中没有while循环)</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if"><a href="#if" class="headerlink" title="if"></a><strong>if</strong></h3><pre><code>同 for 一样， if 语句可以在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在 if 之内。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code>1. 函数可以没有参数或接受多个参数。其声明格式为：func FunName(arg1 Type1, arg2 Type2, ...) Type &#123;&#125;,例如以下的add函数</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>2. 当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。即 x int, y int 可以写成x, y int 3. 函数可以返回任意数量的返回值。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Swap</span><span class="params">(x, y <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><pre><code>1. go语言中的指针也是保存了变量的内存地址，零值为nil。2. 类型*T 是指向T类型的指针。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> <span class="comment">// 指向int型变量的指针</span></span><br></pre></td></tr></table></figure><pre><code>3. &amp; 取地址符号4. * 解引用符号</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">42</span></span><br><span class="line">p = &amp;i</span><br><span class="line">*p = <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>go 没有指针运算</strong></p><h2 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 struct"></a>结构体 struct</h2><pre><code>1. go 语言没有类2. 结构体就是由一个字段组成，例如：</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="type">int</span></span><br><span class="line">    Y <span class="type">int</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>3. 结构体字段可以用.来访问。比如有个结构体变量p，可以用p.X访问X变量。4. 结构体指针访问结构体字段，比如有个结构体指针变量p，可以用(*p).X访问X变量,也可以用p.X进行隐式间接访问。5. 结构体文法，直接列出字段的值来新分配一个结构体。使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。）特殊的前缀 &amp; 返回一个指向结构体的指针。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// 创建一个 Vertex 类型的结构体</span></span><br><span class="line">v2 = Vertex&#123;X: <span class="number">1</span>&#125;  <span class="comment">// Y:0 被隐式地赋予</span></span><br><span class="line">v3 = Vertex&#123;&#125;      <span class="comment">// X:0 Y:0</span></span><br><span class="line">p  = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 创建一个 *Vertex 类型的结构体（指针）</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(v1, p, v2, v3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre><code>1. var name [n]T 表示拥有n个T类型的数组</code></pre><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><pre><code>1. 类型 []T 表示一个元素类型为 T 的切片。2. 可以用短变量声明一个切片，例如：</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><pre><code>3. 可以用make函数创建切片，例如</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>) <span class="comment">//创建一个3个元素，容量为5的切片</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><pre><code>4. 切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[low : high] <span class="comment">//左闭右开区间</span></span><br></pre></td></tr></table></figure><pre><code>5. 切片拥有 长度 和 容量。切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。6. 向切片追加元素：append 函数</code></pre><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><pre><code>1. for 循环的 range 形式可遍历切片或映射。 当使用 for 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;2**%d = %d\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>2. 可以将下标或值赋予 _ 来忽略它。</code></pre><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><pre><code>1. map的声明为：</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[Type1]Type2 <span class="comment">// 将类型Type1 映射到Type2中</span></span><br></pre></td></tr></table></figure><pre><code>2. make 函数会返回给定类型的映射，并将其初始化备用。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m[<span class="string">&quot;Bell Labs&quot;</span>] = <span class="number">1</span></span><br><span class="line">fmt.Println(m[<span class="string">&quot;Bell Labs&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><pre><code>1. 方法就是一类带特殊的 接收者 参数的函数。方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。例如函数add：</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> add() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> v.X + v.Y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><pre><code>接口类型 是由一组方法签名定义的集合。接口类型的变量可以保存任何实现了这些方法的值。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">a = f  <span class="comment">// a MyFloat 实现了 Abser</span></span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex 实现了 Abser</span></span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重建二叉树</title>
    <link href="/2020/12/21/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/12/21/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">重建二叉树</a></h2><pre><code>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。二叉树前序遍历：[根结点 左孩子 右孩子]二叉树中序遍历：[左孩子 根节点 右孩子]思路：因此首先需要从二叉树的前序遍历中找到根结点，然后通过中序遍历找到左子树和右子树。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    id1((根节点))</span><br><span class="line">    id2((左子树))</span><br><span class="line">    id3((右子树))</span><br><span class="line"></span><br><span class="line">    id1--&gt;id2</span><br><span class="line">    id1--&gt;id3</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>因此只要将根节点找到，然后分别计算出左子树结点个数和右子树结点个数，然后分别递归即可。例如有二叉树的前序遍历和中序遍历如下所示：前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]</code></pre><ol><li><p>因此一开始可以得到根节点为3，左子树为[9]，右子树为[15,20,7],如下图所示，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    id1((3))</span><br><span class="line">    id2((9))</span><br><span class="line">    id3((15,20,7))</span><br><span class="line">    id1--&gt;id2</span><br><span class="line">    id1--&gt;id3</span><br></pre></td></tr></table></figure></li><li><p>然后再递归右子树，得到根节点为20, 左孩子和有孩子分别为15和7，如下图所示</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    id1((3))</span><br><span class="line">    id2((9))</span><br><span class="line">    id3((20))</span><br><span class="line">    id4((15))</span><br><span class="line">    id5((7))</span><br><span class="line">    id1--&gt;id2</span><br><span class="line">    id1--&gt;id3</span><br><span class="line">    id3--&gt;id4</span><br><span class="line">    id3--&gt;id5</span><br></pre></td></tr></table></figure><ol start="3"><li>在递归过程中需要记录根节点在中序遍历中的下标，得到根结点下标后，就可以得到<br>左右子树的结点数量大小。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    m[inorder[i]] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>计算左右子树的结点大小<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left = index - is;</span><br><span class="line"><span class="type">int</span> right = ie - index;</span><br></pre></td></tr></table></figure></li></ol><table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody><tr><td>ps</td><td>前序遍历左边界</td></tr><tr><td>pe</td><td>前序遍历右边界</td></tr><tr><td>is</td><td>中序遍历左边界</td></tr><tr><td>ie</td><td>中序遍历右边界</td></tr></tbody></table><p>5.当计算完左右子树的结点大小后，需要计算左右子树边界问题</p><table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody><tr><td>index</td><td>根节点下标</td></tr><tr><td>ps+1</td><td>前序遍历左子树的左边界</td></tr><tr><td>ps+left</td><td>前序遍历左子树的右边界</td></tr><tr><td>is</td><td>中序遍历左子树左边界</td></tr><tr><td>index-1</td><td>中序遍历左子树右边界</td></tr><tr><td>pe - right + 1</td><td>前序遍历右子树的左边界</td></tr><tr><td>pe</td><td>前序遍历右子树的右边界</td></tr><tr><td>index + 1</td><td>中序遍历右子树左边界</td></tr><tr><td>ie</td><td>中序遍历右子树右边界</td></tr></tbody></table><ol start="6"><li>代码<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            m[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="built_in">build</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>, m);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pre, <span class="type">int</span> ps, <span class="type">int</span> pe, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> is, <span class="type">int</span> ie, map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ps &gt; pe) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">int</span> value = pre[ps];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (ps == pe) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> index = m[value];</span><br><span class="line">            <span class="type">int</span> left = index - is;</span><br><span class="line">            <span class="type">int</span> right = ie - index;</span><br><span class="line">            root-&gt;left = <span class="built_in">build</span>(pre, ps + <span class="number">1</span>, ps + left, inorder, is, index - <span class="number">1</span>, m);</span><br><span class="line">            root-&gt;right = <span class="built_in">build</span>(pre, pe - right + <span class="number">1</span>, pe, inorder, index + <span class="number">1</span>, ie, m);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组查找</title>
    <link href="/2020/12/20/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2020/12/20/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">二维数组中的查找</a></h2><pre><code>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。思路：从左下角开始查找，当matrix[i][j] &gt; target，则向上查；当matrix[i][j] &lt; target，则向右查找。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findNumberIn2DArray</span><span class="params">(matrix [][]<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    i := <span class="built_in">len</span>(matrix) - <span class="number">1</span>;</span><br><span class="line">    j := <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]);  &#123;</span><br><span class="line">        <span class="keyword">if</span> matrix[i][j] &gt; target &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[i][j] &lt; target &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>找不同</title>
    <link href="/2020/12/18/%E6%89%BE%E4%B8%8D%E5%90%8C/"/>
    <url>/2020/12/18/%E6%89%BE%E4%B8%8D%E5%90%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="找不同"><a href="#找不同" class="headerlink" title="找不同"></a><a href="https://leetcode-cn.com/problems/find-the-difference/">找不同</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定两个字符串 s 和 t，它们只包含小写字母。</span><br><span class="line">字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。</span><br><span class="line">请找出在 t 中被添加的字母。</span><br></pre></td></tr></table></figure><ul><li>c++<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findTheDifference</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>&amp; c : t) &#123;</span><br><span class="line">            sum += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>&amp; c : s) &#123;</span><br><span class="line">            sum -= c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>go<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTheDifference</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">byte</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> res <span class="type">byte</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(t); i++ &#123;</span><br><span class="line">        res += t[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        res -= s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串压缩</title>
    <link href="/2020/12/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/"/>
    <url>/2020/12/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串压缩"><a href="#字符串压缩" class="headerlink" title="字符串压缩"></a><a href="https://leetcode-cn.com/problems/compress-string-lcci/">字符串压缩</a></h1><pre><code>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母(a至z)。输入：&quot;aabcccccaaa&quot;输出：&quot;a2b1c5a3&quot;</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">compressString</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> S;</span><br><span class="line">        string result;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> c = S[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; S.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == S[i]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(c);</span><br><span class="line">                result += <span class="built_in">to_string</span>(count);</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                c = S[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(c);</span><br><span class="line">        result += <span class="built_in">to_string</span>(count);</span><br><span class="line">        <span class="keyword">return</span> result.<span class="built_in">size</span>() &lt; S.<span class="built_in">size</span>() ? result : S;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异位词分组</title>
    <link href="/2020/12/14/%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <url>/2020/12/14/%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a><a href="https://leetcode-cn.com/problems/group-anagrams/">字母异位词分组</a></h1><pre><code>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]输出:[[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;bat&quot;]]</code></pre><p><strong>思路</strong>：调库就完了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">        map&lt;string, vector&lt;<span class="type">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            string s = strs[i];</span><br><span class="line">            <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;&amp; t = m[s];</span><br><span class="line">            t.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = m.<span class="built_in">begin</span>(); i != m.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">            vector&lt;string&gt; temp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>&amp; index : i-&gt;second) &#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(strs[index]);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并k个有序链表</title>
    <link href="/2020/12/14/mergeKLists/"/>
    <url>/2020/12/14/mergeKLists/</url>
    
    <content type="html"><![CDATA[<h1 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并K个升序链表</a></h1><pre><code>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[1-&gt;4-&gt;5,1-&gt;3-&gt;4,2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><pre><code>使用分治法思想，假设有l1,l2,l3,l4四个链表，首先l1和l2合并成为l12, l3和l4合并成l34，然后l12和l34合并成l。具体的代码如下所示：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[l];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(<span class="built_in">merge</span>(lists, l, mid), <span class="built_in">merge</span>(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* tail = head;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tail-&gt;next = (l1 == <span class="literal">NULL</span> ? l2 : l1);</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unorder_map</title>
    <link href="/2020/12/14/unorder_map/"/>
    <url>/2020/12/14/unorder_map/</url>
    
    <content type="html"><![CDATA[<h1 id="unorder-map"><a href="#unorder-map" class="headerlink" title="unorder_map"></a>unorder_map</h1><p>unordered_map，它是一个关联容器，内部采用的是hash表结构，拥有快速检索的功能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++ 11 新标准</title>
    <link href="/2020/12/14/c++11/"/>
    <url>/2020/12/14/c++11/</url>
    
    <content type="html"><![CDATA[<h1 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h1><h2 id="1-新类型"><a href="#1-新类型" class="headerlink" title="1 新类型"></a>1 新类型</h2><pre><code>1.1 c++11 新增了类型long long 和unsigned long long，支持64位整型。</code></pre><h2 id="2-初始化方式"><a href="#2-初始化方式" class="headerlink" title="2 初始化方式"></a>2 初始化方式</h2><pre><code>2.1 初始化方式，使用初始化列表时，可以添加等号(=)，也可以不用： int x = &#123;5&#125;, double y&#123;5&#125;。初始化列表可用于new 表达式中， int *arr = new int[5]&#123;2 0 0 0 0&#125;。2.2 c++ 11 提供了std::initializer_list,可以用于作构造函数的参数，如：vector&lt;int&gt; a1&#123;10&#125;;vector&lt;int&gt; a2&#123;10&#125;;</code></pre><h2 id="3-声明"><a href="#3-声明" class="headerlink" title="3 声明"></a>3 声明</h2><pre><code>3.1 关键字auto，用于实现自动类型推断，要求进行显示初始化，例如：auto m = 112; // type intauto pt = &amp;m; // pt is type int*3.2 关键字decltype,将变量的类型声明为表达式指定的类型。下面的语句含义是：让y的类型与x的相同，x是一个表达式。decltype(x) y例如：double x; int n;decltype(x*n) q; //将q的里欸选哪个声明为与x*n相同,double3.3 返回类型后置c++11 新增一种函数声明语法：在函数名和参数列表后面指定返回类型：double f1(double, int); // tradictional syntaxauto f2(double, int) -&gt; double;例如：template&lt;typename T, typename U&gt;auto eff(T t, U u) -&gt; decltype(T*U)&#123;&#125;解决了在编译器遇到eff的参数列表前，T和U都还不在作用域内，因此必须在参数列表后使用decltype。3.4 模板别名: using =c++ 11提供了另一种新的创建别名的语法：using itType = std::vector&lt;std::string&gt;::iterator;</code></pre><h2 id="4-Lambda-函数"><a href="#4-Lambda-函数" class="headerlink" title="4 Lambda 函数"></a>4 Lambda 函数</h2><pre><code>语法：[capture list] (params list) mutable exception-&gt; return type &#123; function body &#125;capture list：用于捕获外部变量param list:参数列表return type: 返回类型mutable：用来说用是否可以修改捕获的变量exception：异常设定常见写法：[capture list] (params list) -&gt; return type &#123; function body &#125;[capture list] (params list)&#123; function body &#125;[capture list] &#123; function body &#125;</code></pre><h2 id="5-右值引用（2021-3-5更新）"><a href="#5-右值引用（2021-3-5更新）" class="headerlink" title="5 右值引用（2021-3-5更新）"></a>5 右值引用（2021-3-5更新）</h2><h2 id="6-placement-new"><a href="#6-placement-new" class="headerlink" title="6 placement new"></a>6 placement new</h2><ul><li><p>placement new 是C++中new运算符的变体。一个普通的new运算符主要做了两件事：1)分配内存空间(内存地址由系统分配)；2)在已分配的内存空间上构造对象。</p></li><li><p>而placement new则将这两件事分开，我们可以在指定的内存空间上进行构造对象。</p></li><li><p>语法</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (address) (type) initializer</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>commonNode</title>
    <link href="/2020/12/12/commonNode/"/>
    <url>/2020/12/12/commonNode/</url>
    
    <content type="html"><![CDATA[<h1 id="输入两个链表，找出它们的第一个公共节点。"><a href="#输入两个链表，找出它们的第一个公共节点。" class="headerlink" title="输入两个链表，找出它们的第一个公共节点。"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">输入两个链表，找出它们的第一个公共节点。</a></h1><p><img src="https://i.loli.net/2021/03/05/kLriNCpxcoh76QU.png" alt="1.PNG"><br><strong>思路</strong>：首先算出链表A和链表B各自的长度，然后作差求得两者长度之差，假设差为k，让长的链表先走k步，然后两个链表同时走，直到遇到公共节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">length</span>(headA);</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">length</span>(headB);</span><br><span class="line">        <span class="keyword">if</span> (m &gt;= n) &#123;</span><br><span class="line">            <span class="type">int</span> k = m - n;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getCommon</span>(headA, headB, k);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> k = n - m;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getCommon</span>(headB, headA, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">getCommon</span><span class="params">(ListNode* headA, ListNode* headB, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        ListNode* p = headA;</span><br><span class="line">        <span class="keyword">for</span> (; p &amp;&amp; i &lt; k; i++, p = p-&gt;next);</span><br><span class="line">        <span class="keyword">while</span> ((p &amp;&amp; headB) &amp;&amp; (p != headB)) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            headB = headB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">        ListNode* p = node;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>subArraySum</title>
    <link href="/2020/12/06/subArraySum/"/>
    <url>/2020/12/06/subArraySum/</url>
    
    <content type="html"><![CDATA[<h1 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">连续子数组的最大和</a></h1><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p><strong>设dp[i]是数组中以第i个数结尾的和，则dp[i] 与dp[i-1]有关，若dp[i-1]小于0，则dp[i]=num[i]；否则dp[i]=dp[i-1]+num[i]，因此有动态方程：</strong></p><p>$$<br>dp[i] = num[i]+ max(dp[i],0)<br>$$</p><p><strong>然后求dp数组中的最大值，即可得到子数组的最大和</strong></p><p><strong>然而我们需要的dp数组中的最大值，不需要其他值，因此dp数组中其他数是多余的，只需要一个变量即可，具体代码如下所示，此时时间复杂度为O(n),空间复杂度为O(1)。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">0xf0000000</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0xf0000000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            m = <span class="built_in">max</span>(m, <span class="number">0</span>) + nums[i];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>printTree</title>
    <link href="/2020/12/06/printTree/"/>
    <url>/2020/12/06/printTree/</url>
    
    <content type="html"><![CDATA[<h1 id="从上到下打印二叉树"><a href="#从上到下打印二叉树" class="headerlink" title="从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">从上到下打印二叉树</a></h1><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p><strong>BFS，层次遍历，利用index记录每一层的个数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; v&#123;&#125;;</span><br><span class="line">                <span class="type">int</span> level = q.<span class="built_in">size</span>(); <span class="comment">//记录当前层的结点个数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">                    TreeNode* tmp = q.<span class="built_in">front</span>();</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    v.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span> (tmp-&gt;left) &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (tmp-&gt;right) &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>countOne</title>
    <link href="/2020/12/06/countOne/"/>
    <url>/2020/12/06/countOne/</url>
    
    <content type="html"><![CDATA[<h1 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">二进制中1的个数</a></h1><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p><strong>思路</strong>:利用‘与’运行，因为0 &amp; 1 = 0； 1 &amp; 1 = 1。例如有数1101，然后用1101 &amp; 1 = 1，然后将1101右移一位得到0110，再与1进行‘与’运行，将结果全部相加就可以得到1的个数的和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            res += (n &amp; <span class="number">1</span>);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linklist</title>
    <link href="/2020/12/04/linklist/"/>
    <url>/2020/12/04/linklist/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-关于链表的题"><a href="#Leetcode-关于链表的题" class="headerlink" title="Leetcode 关于链表的题"></a>Leetcode 关于链表的题</h1><ol><li>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></li></ol><p>思路:设置双指针，slow和fast, 首先让fast指针先走k步，然后slow指针和fast一起走，直到fast指针指向最后一个元素，此时slow指向倒数第k个结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; fast; i++, fast = fast-&gt;next);</span><br><span class="line">        <span class="keyword">while</span> (slow &amp;&amp; fast) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">删除链表的节点</a></li></ol><p>输入: head = [4,5,1,9], val = 5</p><p>输出: [4,1,9]</p><p>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre-&gt;next = head;</span><br><span class="line">        ListNode* p = pre-&gt;next;</span><br><span class="line">        ListNode* p2 = pre;</span><br><span class="line">        <span class="keyword">for</span> (; p &amp;&amp; p-&gt;val != val; p = p-&gt;next, p2 = p2-&gt;next);</span><br><span class="line">        p2-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reverseLinkList</title>
    <link href="/2020/12/02/reverseLinkList/"/>
    <url>/2020/12/02/reverseLinkList/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</a></p><pre><code>输入：head = [1,3,2]输出：[2,3,1]</code></pre><p><strong>思路</strong>：首先将链表进行原地逆转。<br>例如有链表：dummy-&gt;1-&gt;3-&gt;2; 首先设置两个临时变量pre, p分别指向值为1的节点和值为3的节点。然后进行循环，修改指针：</p><pre><code>第一次循环：pre-&gt;next = p-&gt;next,即1-&gt;2,p-&gt;next = dummy-&gt;next;即3-&gt;1;dummy-&gt;next = p;即dummy-&gt;3-&gt;1-&gt;2;然后修改p指向值为2的节点第二次循环后就可以得到:dummy-&gt;2-&gt;3-&gt;1;</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* pre = dummy-&gt;next;</span><br><span class="line">        ListNode* p = pre-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (pre-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = dummy-&gt;next;</span><br><span class="line">            dummy-&gt;next = p;</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = dummy;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos</title>
    <link href="/2020/12/01/centos/"/>
    <url>/2020/12/01/centos/</url>
    
    <content type="html"><![CDATA[<h1 id="记录一下linux常用操作"><a href="#记录一下linux常用操作" class="headerlink" title="记录一下linux常用操作"></a>记录一下linux常用操作</h1><h2 id="centos-8-上的换源"><a href="#centos-8-上的换源" class="headerlink" title="centos 8 上的换源"></a>centos 8 上的换源</h2><pre><code> 1 使用命令cd /etc/yum.repos.d, 进入源文件所在目录. 2 然后将之前的源文件备份一下，cp CentOS-Base.repo CentOS-Base.repo.back 3 再使用wget下载源文件，wget -O CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo 4 yum makecache 5 yum update</code></pre><h2 id="记录常见错误，以及解决方法"><a href="#记录常见错误，以及解决方法" class="headerlink" title="记录常见错误，以及解决方法"></a>记录常见错误，以及解决方法</h2><h3 id="常见错误1，xxx不在sudoers文件中"><a href="#常见错误1，xxx不在sudoers文件中" class="headerlink" title="常见错误1，xxx不在sudoers文件中"></a>常见错误1，xxx不在sudoers文件中</h3><pre><code>例如在shell终端输入sudo yum install vim， 此时报错字样为：henry is not in the sudoers file.  This incident will be reported.解决办法：1.首先进入root用户下，在shell终端输入su，然后输入用户密码。2.添加sudo文件的写权限,命令是:chmod u+w /etc/sudoers3.编辑sudoers文件，命令vim /etc/sudoers4.找到这行 root ALL=(ALL) ALL,在他下面添加xxx ALL=(ALL) ALL (这里的xxx是你的用户名)完成！</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>binarySearch</title>
    <link href="/2020/12/01/binarySearch/"/>
    <url>/2020/12/01/binarySearch/</url>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><pre><code>1. 在有序数组nums中查找值为target的下标，查找失败返回-1</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>2. 在有序数组nums中查找都一个比target大的数,失败返回</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>3. 在有序数组nums中查找都target第一次出现和最后一次出现的位置,失败返回[-1,-1].输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4]输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1]</code></pre><p><strong>思路</strong>: 首先先用二分查找找到第一个target出现的位置left，然后查找第一个大于target的位置right，然后用right-1就是target出现最后一次的位置，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">binarySearch</span>(nums, target, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">binarySearch</span>(nums, target, <span class="literal">false</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right &amp;&amp; right &lt; nums.<span class="built_in">size</span>()  &amp;&amp; nums[left] == target &amp;&amp; nums[right] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;left, right&#125;; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt; &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target, <span class="type">bool</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span> ;</span><br><span class="line">        <span class="type">int</span> ans = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target || (flag &amp;&amp; nums[mid] &gt;= target)) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fourSumCount</title>
    <link href="/2020/11/29/fourSumCount/"/>
    <url>/2020/11/29/fourSumCount/</url>
    
    <content type="html"><![CDATA[<h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a><a href="https://leetcode-cn.com/problems/4sum-ii/">四数之和</a></h2><pre><code>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。输入:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]输出:2解释:两个元组如下:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</code></pre><p><strong>思路</strong><br>使用散列表，先将数组A和B中任意两个数之和放入哈希映射中，每一个键是A[i]+B[j],值是对应的次数。然后在数组C和D之间相对应的建，当遇到-(C[k]+D[l])，则答案加1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B, vector&lt;<span class="type">int</span>&gt;&amp; C, vector&lt;<span class="type">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;u : A) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> &amp;v : B) &#123;</span><br><span class="line">                ++count[u+v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;u : C) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> &amp;v : D) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count.<span class="built_in">count</span>(-u-v))</span><br><span class="line">                    ret += count[-(u+v)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>convex-optimization</title>
    <link href="/2020/11/27/convex-opt/"/>
    <url>/2020/11/27/convex-opt/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h1><h2 id="convex-set"><a href="#convex-set" class="headerlink" title="convex set"></a>convex set</h2><h3 id="2-1-Affine-and-convex-set"><a href="#2-1-Affine-and-convex-set" class="headerlink" title="2.1 Affine and convex set"></a>2.1 Affine and convex set</h3><h4 id="2-1-1-Lines-and-line-segment"><a href="#2-1-1-Lines-and-line-segment" class="headerlink" title="2.1.1 Lines and line segment"></a>2.1.1 Lines and line segment</h4><h4 id="2-1-2-Affine-sets"><a href="#2-1-2-Affine-sets" class="headerlink" title="2.1.2 Affine sets"></a>2.1.2 Affine sets</h4><p>​    A set $C \in R^n$ is <strong>affine</strong> if the line through any two distinct points in C lies in C. We refer to a point of the form<br>$ \theta_1x_1+\dots+\theta_k x_k$, where $\theta_1+\dots+\theta_k=1 $, as an affine combination of points $x_1,\dots,x_k$. If C is an affine set, $x_1,\dots,x_k \in C$ and$\theta_1+\dots+\theta_k=1$,then the point $\theta_1x_1+\dots+\theta_k x_k$ also belongs to C.</p><p>​    The set of all affine combinations of points in some $C\subseteq R^n$ is called the <strong>affine hull（仿射包）</strong>of C, and denoted <strong>aff</strong> C:<br>$$<br>aff\quad C = {\theta_1x_1+\dots+\theta_k x_k | x_1, \dots,x_k \in C, \theta_1+\dots+\theta_k=1}<br>$$<br>The affine hull is the smallest affine set that contains C.</p><h4 id="2-1-3-Affine-dimension-and-relative-interior"><a href="#2-1-3-Affine-dimension-and-relative-interior" class="headerlink" title="2.1.3 Affine dimension and relative interior"></a>2.1.3 Affine dimension and relative interior</h4><p>​    The <strong>affine dimension</strong> of a set C as the dimension of its affine hull.</p><p>​    The <strong>relative interior</strong> of a set C is denoted <strong>relint C</strong>,as its interior relative to <strong>aff C</strong>:<br>$$<br>relint \quad C={x\in C|B(x,r) \cap aff \quad C \subseteq C \quad for \quad some \quad r&gt;0}<br>$$<br>where $B(r,x)={ y| ||y-x|| \le r}$.</p><p>​    The <strong>relative boundary</strong> of a set C as cl C \ relint C, where cl C is the closure of C.</p><h4 id="2-1-4-Convex-set"><a href="#2-1-4-Convex-set" class="headerlink" title="2.1.4 Convex set"></a>2.1.4 Convex set</h4><p>​    A set C is convex if the line segment between any two point in C lies in C. i.e., if any $x_1,x_2 \in C$ and any $\theta \in [0,1]$, we have  $\theta x_1+(1-\theta)x_2 \in C$.</p><p>​    We call a point of the from $\theta_1x_1+\dots+\theta_k x_k$, where $\theta_1+\dots+\theta_k=1$ and $\theta_i \ge 0, i=1,\dots,k$, a convex combination of the points  $x_1,\dots,x_k$.</p><p>​    The convex hull of a set C,denoted <strong>conv C</strong>, is the set of all convex combinations  of points in C：</p><p>$$<br>convC={\theta_1x_1+\dots+\theta_k x_k | x_1, \dots,x_k \in C, \theta_1+\dots+\theta_k=1, \theta_i \ge 0, i=1,\dots,k}<br>$$</p><h4 id="2-1-5-Cones"><a href="#2-1-5-Cones" class="headerlink" title="2.1.5 Cones"></a>2.1.5 Cones</h4><p>​    A set C is called a cone, if for every $x \in C$  and $\theta \ge 0$,we have $\theta x \in C$. A set C is convex cone if it is convex and a cone.</p><h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><h4 id="2-2-1-Hyperplanes-and-halfspaces"><a href="#2-2-1-Hyperplanes-and-halfspaces" class="headerlink" title="2.2.1 Hyperplanes and halfspaces"></a>2.2.1 Hyperplanes and halfspaces</h4><p>​    A hyperplane is a set of the form ${x|a^Tx=b}$, where $a\in R^n,a\ne 0$ and $b\in R$. It also has the form ${x|a^T(x-x_0)=0}$, where $x_0$is any point in the hyperplane(any point satisfies $a^Tb=0$).</p><h4 id="2-2-2-Euclidean-balls-and-ellipsoids"><a href="#2-2-2-Euclidean-balls-and-ellipsoids" class="headerlink" title="2.2.2 Euclidean balls and ellipsoids"></a>2.2.2 Euclidean balls and ellipsoids</h4><p>​    A ball in $R^n$ has the form $B(x_c,r)={x| \quad\left|x-x_c\right|_2\le r  }={x| (x-x_c)^T(x-x_c) \le r^2}$</p><h4 id="2-2-3-Norm-balls-and-norm-cones"><a href="#2-2-3-Norm-balls-and-norm-cones" class="headerlink" title="2.2.3 Norm balls and norm cones"></a>2.2.3 Norm balls and norm cones</h4><p>​    A norm ball associated with the norm $\left |·\right |$ is the set ${x | \left|x-x_c\right| \le r}$.</p><p>​    A norm cones associated with the norm  $\left |·\right |$ is the set ${(x,t) | \left|x\right| \le t}$.</p>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长字串</title>
    <link href="/2020/11/26/first/"/>
    <url>/2020/11/26/first/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度</a></p><p><strong>输入实例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度 3</span><br></pre></td></tr></table></figure></li></ul><p><strong>思路</strong></p><p>​    采用滑动窗口的思想，设置两个指针，一个指针<strong>i</strong>指向左边，一个指针<strong>rk</strong> 指向右边，此时最长的字符字串为<strong>s[i]s[i+1]…s[rk]</strong></p><p>，此时长度为<strong>rk-i+1</strong>。具体思路如下所示:</p><ol><li><p>abcabcbb,首先i指针指向第一个字符，可以得到最长的无重复字符字串为(abc)abcbb, ()表示最长的无重复字符字串。</p></li><li><p>abcabcbb a(bca)bcbb</p></li><li><p>abcabcbb,ab(cab)cbb</p></li><li><p>abcabcbb,abc(abc)bb</p></li><li><p>abcabcbb,abca(bc)bb</p></li><li><p>abcabcbb,abcab(cb)b</p></li><li><p>abcabcbb,abcabcb(b)</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">char</span>&gt; check;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> rk = <span class="number">-1</span>, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                check.<span class="built_in">erase</span>(s[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; s.<span class="built_in">size</span>() &amp;&amp; check.<span class="built_in">count</span>(s[rk + <span class="number">1</span>]) == <span class="number">0</span>)&#123;</span><br><span class="line">                check.<span class="built_in">insert</span>(s[rk + <span class="number">1</span>]);</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, rk - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
