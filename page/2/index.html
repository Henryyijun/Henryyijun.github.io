<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-重复项删除" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/09/%E9%87%8D%E5%A4%8D%E9%A1%B9%E5%88%A0%E9%99%A4/" class="article-date">
  <time datetime="2021-03-09T02:00:53.000Z" itemprop="datePublished">2021-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/09/%E9%87%8D%E5%A4%8D%E9%A1%B9%E5%88%A0%E9%99%A4/">重复项删除</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">删除字符串中的所有相邻重复项</a></h1><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。</p>
<p>思路：使用栈保存非重复项，便利字符串，当遇到的字符和栈顶元素相同时，则让栈顶元素退栈，否则入栈，最终将得到的栈转化为字符串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>&amp; ch : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(ch);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ch == s.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.<span class="built_in">push</span>(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>c++string本身提供了类似栈的操作，因为我们不需要开多一个额外的栈进行辅助。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>&amp; ch : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!res.<span class="built_in">empty</span>() &amp;&amp; ch == res.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/09/%E9%87%8D%E5%A4%8D%E9%A1%B9%E5%88%A0%E9%99%A4/" data-id="clafg506c00225ovl8k3o7k0m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-俄罗斯套娃" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/08/%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83/" class="article-date">
  <time datetime="2021-03-08T02:34:37.000Z" itemprop="datePublished">2021-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/08/%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83/">俄罗斯套娃</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="俄罗斯套娃"><a href="#俄罗斯套娃" class="headerlink" title="俄罗斯套娃"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/russian-doll-envelopes/">俄罗斯套娃</a></h1><p>给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。<br>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。<br>请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p>
<p>思路：首先对信封的宽度进行排序，然后求高度的最长递增子序列。求解子序列问题是一个动态规划问题，假设有序列为：<br>num=[2 1 3 5 4 7]。使用dp数组进行记录，dp[i]的值表示以num[i]作为结尾的递增子序列的长度。一开始，dp全部初始化为1， 然后更新dp的动态方程为:<br>$$<br>dp[i] = max_{0&lt;j&lt;i}(dp[i], dp[j] + 1);<br>$$</p>
<p>1 dp数组初始化<br>|num|2|1|3|5|4|7|<br>|–|–|–|–|–|–|–|<br>|dp|1|1|1|1|1|1|</p>
<p>2 更新dp[1]<br>因为num[1] &gt; num[0]不成立，所以dp[1] = 1。<br>|num|2|1|3|5|4|7|<br>|–|–|–|–|–|–|–|<br>|dp|1|1|1|1|1|1|</p>
<p>3 更新dp[2]<br>因为num[2] &gt; num[0]成立，所以dp[2] = dp[0]+1;<br>因为num[2] &gt; num[1]成立，所以dp[2] = dp[1]+1;<br>最后dp[2] = ，max(dp[1]+1,dp[0]+1);所以dp[2]=2。<br>|num|2|1|3|5|4|7|<br>|–|–|–|–|–|–|–|<br>|dp|1|1|2|1|1|1|</p>
<p>3 依次类推更新其他值<br>|num|2|1|3|5|4|7|<br>|–|–|–|–|–|–|–|<br>|dp|1|1|2|3|3|4|</p>
<ol start="4">
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxEnvelopes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(envelopes.<span class="built_in">begin</span>(), envelopes.<span class="built_in">end</span>(), [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        &#125;); <span class="comment">//首先进行排序</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(envelopes.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; envelopes.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (envelopes[i][<span class="number">1</span>] &gt; envelopes[j][<span class="number">1</span>] &amp;&amp; envelopes[i][<span class="number">0</span>] &gt; envelopes[j][<span class="number">0</span>]) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>); <span class="comment">//对高度求最长递增子序列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/08/%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83/" data-id="clafg5062001g5ovl8g868hij" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-espirit" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/04/espirit/" class="article-date">
  <time datetime="2021-03-04T11:25:52.000Z" itemprop="datePublished">2021-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/04/espirit/">espirit</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ESPIRiT-An-Eigenvalue-Approach-to-Autocalibrating-Parallel-MRI"><a href="#ESPIRiT-An-Eigenvalue-Approach-to-Autocalibrating-Parallel-MRI" class="headerlink" title="ESPIRiT - An Eigenvalue Approach to Autocalibrating Parallel MRI"></a>ESPIRiT - An Eigenvalue Approach to Autocalibrating Parallel MRI</h1><h2 id="1-THEORY"><a href="#1-THEORY" class="headerlink" title="1 THEORY"></a>1 THEORY</h2><h3 id="1-1SENSE"><a href="#1-1SENSE" class="headerlink" title="1.1SENSE"></a>1.1SENSE</h3><p>&ensp;&ensp; 在MRI重建中，SENSE类方法将MRI重建视作为一个线性逆问题。假设m表示一张图像，令$S_i$ 表示第i个线圈的敏感度矩阵(对角矩阵),$F$表示离散傅里叶变换，$P$表示采样矩阵。则第i个线圈得到的数据可以表示为:<br>$$<br>y_i = PFS_i m  \quad (1)<br>$$<br>当$S_i$已知时，该问题可以直接通过最小二乘法求解。</p>
<h3 id="1-2-GRAPPPA"><a href="#1-2-GRAPPPA" class="headerlink" title="1.2 GRAPPPA"></a>1.2 GRAPPPA</h3><p>&ensp;&ensp; GRAPPA是一种逐线圈自动校准的重建算法，该算法将重建过程视作为一个k空间的插值过程，将未获得k空间数据通过已获得的数据进行线性组合得到。</p>
<p>&ensp;&ensp;为了描述GRAPPA算法，定义一些符号</p>
<ul>
<li>$R_r$ :该算子表示从位置r周围的所有网格中选择一个k空间块。</li>
<li>$P_r$ :仅从k空间块中选择采集样本的局部采样模式。</li>
<li>$y$ :向量形式的多线圈k空间网格，未获取的数据被零填充。</li>
<li>$x_i$ :第i个线圈中重建后得到的数据</li>
<li>$x_i(r)$ :第i个线圈中，位置r的重建数据</li>
<li>$g_{ri}$ :GRAPPA kernel</li>
</ul>
<p>&ensp;&ensp;在GRAPPA重建算法中，在位置r中未采样的数据由以下式子得到：<br>$$<br>x_i(r)=(P_rR_ry)^Tg_{ri} \quad (2)<br>$$<br>因此当GRAPPA kernel未知，$x_i$已知时，我们可以通过求解(2)得到$g_{ri}$。一般情况下，在得到的k空间数据中有一块全采样的数据，位于数据中心，这块数据被称为校准数据(calibration data),通过该数据得到矩阵被称为标准矩阵(calibration matrix)，记为A。如Figure 1，左上角为得到的k空间数据，该数据中央黑色部分为全采样，即为标准矩阵(上中图)。上右图是校准数据得到的校准矩阵，该矩阵通过设置一个窗口(3*3),然后将窗口中的数据拉成一行向量，即可以得到校准矩阵的一行向量，再通过滑动该窗口，不断得到校准矩阵的数据。</p>
<p>&ensp;&ensp; 为了得到GRAPPA kernel，使用校准矩阵改写式子(2),</p>
<p>$$<br>\begin{aligned}<br>x_i(r)&amp;=(P_rR_ry)^Tg_{ri} \<br>          &amp;=y^TR_r^TP_r^Tg_{ri}\<br>          &amp;=(R_ry)^TP_r^Tg_{ri} \<br>          &amp;=AP_r^Tg_{ri}<br>\end{aligned}<br>$$<br>若用$y_i^{AC}$表示第i个线圈得到的校准数据，则可以得到式子(3)<br>$$<br>y_i^{AC} = AP_r^Tg_{ri} \quad (3)<br>$$<br>通过求解式子(3), 可以得到未知的$g_{ri}$，一般通过Tikhonov正则化最小二乘法进行求解。<br>$$<br>argmin_{g_{ri}} \Vert AP_r^T-y_i^{AC} \Vert^2<br>$$</p>
<p>通过构造，矩阵A的一个列是$y_i^{AC}$，如Figure 1 中上中图和上右图所以，橙色部分的一块一矩阵即为矩阵A的第五列。因为可以将$y_i^{AC}$写成 $Ae_i$,$e_i$表示某个位置为1，其他为0为的向量，用于选择矩阵的第i列。因此通过该性质，重写式子(3),可以写成：</p>
<p>$$<br>\begin{aligned}<br>0&amp;=AP_r^Tg_{ri}-y_i^{AC}\<br>&amp;=AP_r^Tg_{ri}-Ae_i \<br>&amp;=A(P_r^Tg_{ri} - e_i) \quad (4)<br>\end{aligned}<br>$$<br>从式子(4)中可以发现，$P_r^Tg_{ri} - e_i$是矩阵A的零空间向量。零空间的存在意味着A中存在冗余，从而意味着k空间块之间的相关性，这可以用来合成丢失的样本。由于零空间的特殊性，因此我们可以直接分析零空间。</p>
<p><img src="https://i.loli.net/2021/03/08/OaNkGrSzJKZADVb.png" alt="Figure 1"></p>
<h3 id="1-3-SVD和零空间重建"><a href="#1-3-SVD和零空间重建" class="headerlink" title="1.3 SVD和零空间重建"></a>1.3 SVD和零空间重建</h3><p>&ensp;&ensp; 使用奇异值分解的方法分析校准矩阵A，奇异值分解的形式为：<br>$$<br>A=U\Sigma V^H \quad (5)<br>$$<br>矩阵V的列是矩阵行空间的基，因此可以将矩阵V分成$V_{\bot}$和$V_{\Vert}$,分别span A的零空间和行空间。从Figure 2 中可以看出，对校准矩阵矩阵进行奇异值分解后，我们可以利用$V_{\Vert}$的数据推出未采样的数据。</p>
<p>&ensp;&ensp; 给定欠采样的k空间网格，重构x的每个k空间块必须满足两个约束:<br>$$<br>\begin{aligned}<br>V_{\Vert}V_{\Vert}^HR_rx &amp;= R_rx  \quad or \quad V_{\bot}^HR_rx = 0 \quad &amp;(6a)\<br>P_rR_rx&amp;=P_rR_rx \quad &amp;(6b)<br>\end{aligned}<br>$$<br>(6a)是与校准的一致性，(6b)是与数据采集的一致性。在最小二乘意义上解释(形式上超定的)零空间约束集产生了正规方程</p>
<p>$$<br>\sum_{r}R_r^HV_{\bot}V_{\bot}^HR_rx = 0 \quad (7)<br>$$</p>
<p>式子(7)进一步可以写成</p>
<p>$$<br>\sum_{r}R_r^H (I- V_{\Vert}V_{\Vert}^H) R_rx = 0 \quad (8)<br>$$</p>
<p>$$<br>M^{-1}\sum_{r}R_r^H V_{\Vert}V_{\Vert}^H R_rx = 0 \quad (9)<br>$$<br>其中式子(9)中的M表示$\sum_{r}R_r^HR_r$。以矩阵形式重写第一个约束，并合并第二个约束的所有相同的方程，得到<br>$$<br>\begin{aligned}<br>\mathcal{W}x &amp;=x  \quad (10a)\<br>\mathcal{P}x &amp;= \mathcal{P}y \quad (10b)<br>\end{aligned}<br>$$</p>
<p><img src="https://i.loli.net/2021/03/08/aPNvjHZbIAgxSym.png" alt="Figure 2"></p>
<h3 id="1-4-Sensitivity-map-as-an-eigenvalue-problem"><a href="#1-4-Sensitivity-map-as-an-eigenvalue-problem" class="headerlink" title="1.4 Sensitivity map as an eigenvalue problem"></a>1.4 Sensitivity map as an eigenvalue problem</h3><p>&ensp; &ensp; 假设x是W-I的零空间的解，则满足$Wx=x$。如果我们用线圈灵敏度加权的原始图像的k空间表示x，得到<br>$$<br>x=FSm \quad (11)<br>$$<br>其中，$S=[S_1,S_2,…,S_N]^T$ 是堆叠线圈灵敏度的向量，则等式(10a)可以写为：<br>$$<br>WFSm = FSm \quad (12)<br>$$<br>两边都进行傅里叶逆变换可以得到，<br>$$<br>F^{-1}WFSm=Sm \quad (13)<br>$$<br>通过式子(13)可以看出，1是矩阵$F^{-1}WF$的特征值，特征向量是$Sm$.因为算子W是半正定矩阵值卷积，所以它在图像域中解耦成点态半正定矩阵运算:<br>$$<br>F^{-1}\mathcal{W}F|_q=\mathcal{G_q} \quad (14)<br>$$<br>算子W的特征值分解被简化为求解图像空间中$G_q$每个位置q的特征值分解。计算$G_q$的过程如Figure 4所示。定义在位置q上的敏感度$\vec{s}(q)=[s_1(q),…,s_N(q)]^T$,则等式(13)可以推出：<br>$$<br>\mathcal{G_q}\vec{s}(q)m(q)=\vec{s_r}m(q) \quad (15)<br>$$<br>假设$m(q)$不等于0，则可以得到：<br>$$<br>\mathcal{G_q}\vec{s}(q)=\vec{s_q} \quad (15)<br>$$<br>因此，显式灵敏度图可以通过所有Gq的特征值分解找到，只选择对应于特征值” =1 “的特征向量<br><img src="https://i.loli.net/2021/03/08/uXNIlDFy2h6kYe3.png" alt="Figure 4"></p>
<h3 id="1-5-ESPIRiT-Implementation-Using-Soft-SENSE"><a href="#1-5-ESPIRiT-Implementation-Using-Soft-SENSE" class="headerlink" title="1.5 ESPIRiT : Implementation Using Soft SENSE"></a>1.5 ESPIRiT : Implementation Using Soft SENSE</h3><p>&ensp;&ensp;在计算一组灵敏度后，可以执行标准的SENSE重建。在某些情况下，采集中的误差会导致出现特征值为“=1”的多个特征向量或小于1的附加特征值，这表明信号分量不能用严格的SENSE模式来解释。这推动了重建过程的扩展:不是使用一组单一的灵敏度图，而是使用等式(1)扩展到“软”SENSE重建，其使用基于多个图像分量$m^j$和多组映射$S^j$的信号的松弛模型:</p>
<p>$$<br>y_i=\mathcal{P} \mathcal{F}\sum_{j=1}^{M}S_i^jm^j \quad (16)<br>$$<br>如上所述，重建图像的求解为一个优化问题，并且使用正则化方法，具体的形式如下所示：</p>
<p>$$<br>J(m^1,…,m^M)=\sum_{i=1}^{N}\Vert y_i-\mathcal{P} \mathcal{F}\sum_{j=1}^{M}S_i^jm^j \Vert^2_2 + \alpha\sum_{j=1}^{M}\mathcal{Qm^j}  \quad (17)<br>$$</p>
<h2 id="2-code-Implementation-demo-ESPIRIT-l1-recon"><a href="#2-code-Implementation-demo-ESPIRIT-l1-recon" class="headerlink" title="2 code Implementation(demo_ESPIRIT_l1_recon)"></a>2 code Implementation(demo_ESPIRIT_l1_recon)</h2><h3 id="2-1-construct-Calibration-matrix-A-and-V-Vert"><a href="#2-1-construct-Calibration-matrix-A-and-V-Vert" class="headerlink" title="2.1 construct Calibration matrix A and $V_{\Vert}$"></a>2.1 construct Calibration matrix A and $V_{\Vert}$</h3><p>&ensp;&ensp;构造校准矩阵A之前，首先必须找到ACS，通过使用函数crop寻找校准区域<code>calib</code>，然后通过<code>calib</code>构造校准矩阵。</p>
<p>&ensp;&ensp;各类函数解释说明</p>
<ul>
<li><code>im2row(im, winSize)</code>:该函数将滑动窗口的数据拉成行向量，然后不用滑动窗口，得到一个Hankel矩阵。如<code>Figure 5</code>所示</li>
</ul>
<p><img src="https://i.loli.net/2021/03/22/3RKe5hN1rdlpZSo.png" alt="Figure 5"></p>
<ul>
<li>函数<code>dat2Kernel</code>:该函数接受两个参数，分别是<code>data</code>和<code>kSize</code>，表示校准数据和<code>kernel</code>的大小。该函数首先通过调用im2row函数得到临时变量<code>tmp</code>，然后将<code>tmp reshape</code>成二维矩阵，对A矩阵进行<code>SVD</code>分解，对应公式(5)。进行分解之后，将A的右奇异向量取出，<code>reshape</code>成一个一个的kernel。变换过程如下图所示：<br><img src="https://i.loli.net/2021/03/22/D3fVXc8QwIlYRHs.png" alt="Figure 6"><br><img src="https://i.loli.net/2021/03/22/vnyrdfjXYiVCsa9.png" alt="Figure 7"></li>
</ul>
<ul>
<li><code>[EigenVecs, EigenVals] = kernelEig(kernel, imSize)</code>:还函数用于计算特征向量和特征值。<code>kernel</code>是上一个函数<code>dat2Kernel</code>得到的结果并且去掉一些奇异值特别小的右奇异向量。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/04/espirit/" data-id="clafg505c000d5ovl0f8z0mvu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MRI/" rel="tag">MRI</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-倒数第k个结点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/20/%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/" class="article-date">
  <time datetime="2021-01-20T10:09:17.000Z" itemprop="datePublished">2021-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/20/%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/">倒数第k个结点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="输出该链表中倒数第k个节点"><a href="#输出该链表中倒数第k个节点" class="headerlink" title="输出该链表中倒数第k个节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">输出该链表中倒数第k个节点</a></h1><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.<br>返回链表 4-&gt;5.</p>
<p>思路：使用双指针，一个快指针，一个慢指针，先让快指针走k步，然后快慢指针一起走，直到快指针指向链表尾部时，慢指针就指向链表倒数第k个结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; fast; i++, fast = fast-&gt;next);</span><br><span class="line">        <span class="keyword">while</span> (slow &amp;&amp; fast) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/20/%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/" data-id="clafg5063001j5ovlhwkm322f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-机器人的运动范围" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/19/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/" class="article-date">
  <time datetime="2021-01-19T10:47:09.000Z" itemprop="datePublished">2021-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/19/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/">机器人的运动范围</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">机器人的运动范围</a></h1><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p>输入：m = 2, n = 3, k = 1</p>
<p>输出：3</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>(0 0)</td>
<td>(0 1)</td>
<td>(0 2)</td>
</tr>
<tr>
<td>1</td>
<td>(1 0)</td>
<td>(1 1)</td>
<td>(1 2)</td>
</tr>
</tbody></table>
<p>因为机器人能够到达的格子是(0 0),(0 1), (1 0)。<br>思路：使用DFS或者BFS进行搜索，用一个全局变量记录符合条件的格子数。</p>
<p>DFS思路：使用一个vis数组，记录访问过的各自，true为访问过，false为未访问。<br>DFS函数参数：vis,m,n,x(当前格子横坐标),y(当前格子纵坐标)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">vis</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n));</span><br><span class="line">    <span class="built_in">dfs</span>(vis, m, n, <span class="number">0</span>, <span class="number">0</span>, k);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; vis, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; direction&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; i : direction) &#123;</span><br><span class="line">        <span class="type">int</span> a = x + i.first;</span><br><span class="line">        <span class="type">int</span> b = y + i.second;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; m &amp;&amp; b &lt; n &amp;&amp; !vis[a][b] &amp;&amp; <span class="built_in">count</span>(a, b) &lt;= k)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="built_in">dfs</span>(vis, m, n, a, b, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        sum = sum + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        sum = sum + y % <span class="number">10</span>;</span><br><span class="line">        y /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BFS</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">vis</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n));</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; path;</span><br><span class="line">    path.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; direction&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    vis[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!path.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [x, y] = path.<span class="built_in">front</span>();</span><br><span class="line">        path.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; d : direction) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + d.first &gt;= m || y + d.second &gt;= n || vis[x + d.first][y + d.second] || <span class="built_in">count</span>(x + d.first, y + d.second) &gt; k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                vis[x+d.first][y+d.second] = <span class="literal">true</span>;</span><br><span class="line">                path.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x+d.first, y+d.second));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/19/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/" data-id="clafg506a00205ovl78vp3jjt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-冗余连接" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/13/%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/" class="article-date">
  <time datetime="2021-01-13T05:30:37.000Z" itemprop="datePublished">2021-01-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/13/%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/">冗余连接</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="冗余连接"><a href="#冗余连接" class="headerlink" title="冗余连接"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/redundant-connection/">冗余连接</a></h2><pre><code>在本问题中, 树指的是一个连通且无环的无向图。

输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。

返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。


输入: [[1,2], [1,3], [2,3]]
输出: [2,3]
解释: 给定的无向图为:
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id1((1))</span><br><span class="line">id2((2))</span><br><span class="line">id3((3))</span><br><span class="line">id1---id2</span><br><span class="line">id1---id3</span><br><span class="line">id2---id3</span><br></pre></td></tr></table></figure>
<pre><code>解释：因此该图可以删除边[2,3],使之成为一个树

思路：利用并查集的思想，并查集是一个不相交的集合，一般可以用于连通片的计算等。
最经常用的地方就是在克鲁斯卡尔生成树算法中。
并查集可以用数组的形式进行实现，例如有一个图[[1,2], [2,3], [3,4], [1,4], [1,5]]。
</code></pre>
<ol>
<li>并查集一开始初始化为如下表所示：</li>
</ol>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>father</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody></table>
<ol start="2">
<li>然后逐渐添加边，</li>
</ol>
<table>
<thead>
<tr>
<th>index</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>father</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>3. 代码如下所示</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">father</span><span class="params">(edges.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; father.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(father, edge[<span class="number">0</span>]) != <span class="built_in">find</span>(father, edge[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="built_in">Union</span>(father, edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; father, <span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        father[<span class="built_in">find</span>(father, a)] = father[<span class="built_in">find</span>(father, b)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span>  <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; father, <span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (a != father[a]) &#123;</span><br><span class="line">            a = father[a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/13/%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/" data-id="clafg5067001q5ovl3at284hk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-go" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/25/go/" class="article-date">
  <time datetime="2020-12-25T10:09:56.000Z" itemprop="datePublished">2020-12-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/25/go/">go</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Go语言"><a href="#Go语言" class="headerlink" title="Go语言"></a>Go语言</h1><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><pre><code>1. 每个 Go 程序都是由包构成的。程序从 main 包开始运行。本程序通过导入路径 &quot;fmt&quot; 来使用它
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>2. 此代码用圆括号组合了导入，这是“分组”形式的导入语句。也可以编写多个导入语句，例如：
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><pre><code>1. var 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。
2. 变量声明可以包含初始值，每个变量对应一个。
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">var</span> c, python, java <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> i, j <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">	fmt.Println(i, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>3. 短变量声明：在函数中，简洁赋值语句 := 可在类型明确的地方代替 var 声明。函数外的每个语句都必须以关键字开始（var, func 等等），因此 := 结构不能在函数外使用。
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i, j <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">	k := <span class="number">3</span></span><br><span class="line">	c, python, java := <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;no!&quot;</span></span><br><span class="line">	fmt.Println(i, j, k, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>4. 基本类型：
bool
string
int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr
byte // uint8 的别名
rune // int32 的别名
    // 表示一个 Unicode 码点
float32 float64
complex64 complex128

5. 常量：常量的声明与变量类似，只不过是使用 const 关键字。常量可以是字符、字符串、布尔值或数值。常量不能用 := 语法声明。
</code></pre>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a><strong>for</strong></h3><pre><code>1. Go 只有一种循环结构：for 循环。
2. 基本的 for 循环由三部分组成，它们用分号隔开：
    初始化语句：在第一次迭代前执行
    条件表达式：在每次迭代前求值
    后置语句：在每次迭代的结尾执行
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		sum += i</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3. 去掉分号的for循环就成了while循环(go语言中没有while循环)
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sum := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">		sum += sum</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a><strong>if</strong></h3><pre><code>同 for 一样， if 语句可以在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在 if 之内。
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">		<span class="keyword">return</span> v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(</span><br><span class="line">		pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">		pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>),</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code>1. 函数可以没有参数或接受多个参数。其声明格式为：
func FunName(arg1 Type1, arg2 Type2, ...) Type &#123;&#125;,例如以下的add函数
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>2. 当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。
即 x int, y int 可以写成x, y int 

3. 函数可以返回任意数量的返回值。
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Swap</span><span class="params">(x, y <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><pre><code>1. go语言中的指针也是保存了变量的内存地址，零值为nil。
2. 类型*T 是指向T类型的指针。
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span> <span class="comment">// 指向int型变量的指针</span></span><br></pre></td></tr></table></figure>
<pre><code>3. &amp; 取地址符号
4. * 解引用符号
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">42</span></span><br><span class="line">p = &amp;i</span><br><span class="line">*p = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><strong>go 没有指针运算</strong></p>
<h2 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 struct"></a>结构体 struct</h2><pre><code>1. go 语言没有类
2. 结构体就是由一个字段组成，例如：
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="type">int</span></span><br><span class="line">    Y <span class="type">int</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>3. 结构体字段可以用.来访问。比如有个结构体变量p，可以用p.X访问X变量。
4. 结构体指针访问结构体字段，比如有个结构体指针变量p，可以用(*p).X访问X变量,
也可以用p.X进行隐式间接访问。
5. 结构体文法，直接列出字段的值来新分配一个结构体。
使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。）
特殊的前缀 &amp; 返回一个指向结构体的指针。
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// 创建一个 Vertex 类型的结构体</span></span><br><span class="line">	v2 = Vertex&#123;X: <span class="number">1</span>&#125;  <span class="comment">// Y:0 被隐式地赋予</span></span><br><span class="line">	v3 = Vertex&#123;&#125;      <span class="comment">// X:0 Y:0</span></span><br><span class="line">	p  = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 创建一个 *Vertex 类型的结构体（指针）</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(v1, p, v2, v3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre><code>1. var name [n]T 表示拥有n个T类型的数组
</code></pre>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><pre><code>1. 类型 []T 表示一个元素类型为 T 的切片。
2. 可以用短变量声明一个切片，例如：
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3. 可以用make函数创建切片，例如
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>) <span class="comment">//创建一个3个元素，容量为5的切片</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<pre><code>4. 切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[low : high] <span class="comment">//左闭右开区间</span></span><br></pre></td></tr></table></figure>
<pre><code>5. 切片拥有 长度 和 容量。切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。
6. 向切片追加元素：append 函数
</code></pre>
<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><pre><code>1. for 循环的 range 形式可遍历切片或映射。 当使用 for 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;2**%d = %d\n&quot;</span>, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>2. 可以将下标或值赋予 _ 来忽略它。
</code></pre>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><pre><code>1. map的声明为：
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[Type1]Type2 <span class="comment">// 将类型Type1 映射到Type2中</span></span><br></pre></td></tr></table></figure>
<pre><code>2. make 函数会返回给定类型的映射，并将其初始化备用。
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	m[<span class="string">&quot;Bell Labs&quot;</span>] = <span class="number">1</span></span><br><span class="line">	fmt.Println(m[<span class="string">&quot;Bell Labs&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><pre><code>1. 方法就是一类带特殊的 接收者 参数的函数。方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。例如函数add：
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> add() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v.X + v.Y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><pre><code>接口类型 是由一组方法签名定义的集合。
接口类型的变量可以保存任何实现了这些方法的值。
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Abs() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a Abser</span><br><span class="line">	f := MyFloat(-math.Sqrt2)</span><br><span class="line">	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	a = f  <span class="comment">// a MyFloat 实现了 Abser</span></span><br><span class="line">	a = &amp;v <span class="comment">// a *Vertex 实现了 Abser</span></span><br><span class="line">	fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/25/go/" data-id="clafg505k000k5ovl64g5dhtj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-重建二叉树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/21/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/" class="article-date">
  <time datetime="2020-12-21T08:57:03.000Z" itemprop="datePublished">2020-12-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/21/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/">重建二叉树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">重建二叉树</a></h2><pre><code>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍
历和中序遍历的结果中都不含重复的数字。

二叉树前序遍历：[根结点 左孩子 右孩子]
二叉树中序遍历：[左孩子 根节点 右孩子]

思路：因此首先需要从二叉树的前序遍历中找到根结点，然后通过中序遍历找到左
子树和右子树。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    id1((根节点))</span><br><span class="line">    id2((左子树))</span><br><span class="line">    id3((右子树))</span><br><span class="line"></span><br><span class="line">    id1--&gt;id2</span><br><span class="line">    id1--&gt;id3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>因此只要将根节点找到，然后分别计算出左子树结点个数和右子树结点个数，然后分别递归即可。
例如有二叉树的前序遍历和中序遍历如下所示：
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
</code></pre>
<ol>
<li><p>因此一开始可以得到根节点为3，左子树为[9]，右子树为[15,20,7],如下图所示，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    id1((3))</span><br><span class="line">    id2((9))</span><br><span class="line">    id3((15,20,7))</span><br><span class="line">    id1--&gt;id2</span><br><span class="line">    id1--&gt;id3</span><br></pre></td></tr></table></figure></li>
<li><p>然后再递归右子树，得到根节点为20, 左孩子和有孩子分别为15和7，如下图所示</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    id1((3))</span><br><span class="line">    id2((9))</span><br><span class="line">    id3((20))</span><br><span class="line">    id4((15))</span><br><span class="line">    id5((7))</span><br><span class="line">    id1--&gt;id2</span><br><span class="line">    id1--&gt;id3</span><br><span class="line">    id3--&gt;id4</span><br><span class="line">    id3--&gt;id5</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在递归过程中需要记录根节点在中序遍历中的下标，得到根结点下标后，就可以得到<br>左右子树的结点数量大小。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    m[inorder[i]] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>计算左右子树的结点大小<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left = index - is;</span><br><span class="line"><span class="type">int</span> right = ie - index;</span><br></pre></td></tr></table></figure></li>
</ol>
<table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ps</td>
<td>前序遍历左边界</td>
</tr>
<tr>
<td>pe</td>
<td>前序遍历右边界</td>
</tr>
<tr>
<td>is</td>
<td>中序遍历左边界</td>
</tr>
<tr>
<td>ie</td>
<td>中序遍历右边界</td>
</tr>
</tbody></table>
<p>5.当计算完左右子树的结点大小后，需要计算左右子树边界问题</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>根节点下标</td>
</tr>
<tr>
<td>ps+1</td>
<td>前序遍历左子树的左边界</td>
</tr>
<tr>
<td>ps+left</td>
<td>前序遍历左子树的右边界</td>
</tr>
<tr>
<td>is</td>
<td>中序遍历左子树左边界</td>
</tr>
<tr>
<td>index-1</td>
<td>中序遍历左子树右边界</td>
</tr>
<tr>
<td>pe - right + 1</td>
<td>前序遍历右子树的左边界</td>
</tr>
<tr>
<td>pe</td>
<td>前序遍历右子树的右边界</td>
</tr>
<tr>
<td>index + 1</td>
<td>中序遍历右子树左边界</td>
</tr>
<tr>
<td>ie</td>
<td>中序遍历右子树右边界</td>
</tr>
</tbody></table>
<ol start="6">
<li>代码<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            m[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="built_in">build</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>, m);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pre, <span class="type">int</span> ps, <span class="type">int</span> pe, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> is, <span class="type">int</span> ie, map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ps &gt; pe) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">int</span> value = pre[ps];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(value);</span><br><span class="line">        <span class="keyword">if</span> (ps == pe) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> index = m[value];</span><br><span class="line">            <span class="type">int</span> left = index - is;</span><br><span class="line">            <span class="type">int</span> right = ie - index;</span><br><span class="line">            root-&gt;left = <span class="built_in">build</span>(pre, ps + <span class="number">1</span>, ps + left, inorder, is, index - <span class="number">1</span>, m);</span><br><span class="line">            root-&gt;right = <span class="built_in">build</span>(pre, pe - right + <span class="number">1</span>, pe, inorder, index + <span class="number">1</span>, ie, m);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/21/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/" data-id="clafg506d00245ovl22dzhcq0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-二维数组查找" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/20/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/" class="article-date">
  <time datetime="2020-12-20T10:28:03.000Z" itemprop="datePublished">2020-12-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/20/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/">二维数组查找</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">二维数组中的查找</a></h2><pre><code>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

思路：从左下角开始查找，当matrix[i][j] &gt; target，则向上查；当matrix[i][j] &lt; target，则向右查找。
</code></pre>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findNumberIn2DArray</span><span class="params">(matrix [][]<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    i := <span class="built_in">len</span>(matrix) - <span class="number">1</span>;</span><br><span class="line">    j := <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]);  &#123;</span><br><span class="line">        <span class="keyword">if</span> matrix[i][j] &gt; target &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[i][j] &lt; target &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/20/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/" data-id="clafg5061001e5ovl75xzhj5b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-找不同" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/18/%E6%89%BE%E4%B8%8D%E5%90%8C/" class="article-date">
  <time datetime="2020-12-18T08:40:13.000Z" itemprop="datePublished">2020-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/18/%E6%89%BE%E4%B8%8D%E5%90%8C/">找不同</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="找不同"><a href="#找不同" class="headerlink" title="找不同"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-difference/">找不同</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定两个字符串 s 和 t，它们只包含小写字母。</span><br><span class="line">字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。</span><br><span class="line">请找出在 t 中被添加的字母。</span><br></pre></td></tr></table></figure>
<ul>
<li>c++<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findTheDifference</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>&amp; c : t) &#123;</span><br><span class="line">            sum += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>&amp; c : s) &#123;</span><br><span class="line">            sum -= c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>go<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTheDifference</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">byte</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> res <span class="type">byte</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(t); i++ &#123;</span><br><span class="line">        res += t[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        res -= s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/18/%E6%89%BE%E4%B8%8D%E5%90%8C/" data-id="clafg5069001w5ovlc81198oz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-STL/" rel="tag">C++, STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MRI/" rel="tag">MRI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MRI%E9%87%8D%E5%BB%BA/" rel="tag">MRI重建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/" rel="tag">math</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 17.5px;">C++</a> <a href="/tags/C-STL/" style="font-size: 10px;">C++, STL</a> <a href="/tags/MRI/" style="font-size: 10px;">MRI</a> <a href="/tags/MRI%E9%87%8D%E5%BB%BA/" style="font-size: 10px;">MRI重建</a> <a href="/tags/c/" style="font-size: 10px;">c++</a> <a href="/tags/golang/" style="font-size: 10px;">golang</a> <a href="/tags/leetcode/" style="font-size: 20px;">leetcode</a> <a href="/tags/linux/" style="font-size: 12.5px;">linux</a> <a href="/tags/math/" style="font-size: 15px;">math</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/13/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/04/22/tightFrameRes/">tightFrameRes</a>
          </li>
        
          <li>
            <a href="/2021/04/20/admm/">admm</a>
          </li>
        
          <li>
            <a href="/2021/04/01/linux/">linux</a>
          </li>
        
          <li>
            <a href="/2021/03/31/soft-threshold/">soft-threshold</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>